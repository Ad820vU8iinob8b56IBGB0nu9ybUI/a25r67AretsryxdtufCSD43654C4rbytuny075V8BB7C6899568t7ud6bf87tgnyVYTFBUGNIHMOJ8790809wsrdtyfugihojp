<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kowbi | AI Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        /* Dark theme is the default */
        :root {
            --background: #000000;
            --primary-text: #eaeaea;
            --secondary-text: #888888;
            --card-bg: #111111;
            --input-bg: #191919;
            --border-color: #222222;
            --accent: #FFFFFF;
            --accent-hover: #DDDDDD;
            --danger: #E53E3E;
            --edit: #3b82f6;
        }

        /* Light theme overrides */
        [data-theme="light"] {
            --background: #f8fafc; /* slate-50 */
            --primary-text: #0f172a; /* slate-900 */
            --secondary-text: #64748b; /* slate-500 */
            --card-bg: #ffffff;
            --input-bg: #f1f5f9; /* slate-100 */
            --border-color: #e2e8f0; /* slate-200 */
            --accent: #0f172a; /* slate-900 */
            --accent-hover: #334155; /* slate-700 */
        }

        body {
            background-color: var(--background);
            color: var(--primary-text);
            font-family: 'Manrope', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .form-input, .form-select {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--primary-text);
            padding: 0.75rem 1rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent);
        }

        .form-label {
            color: var(--secondary-text);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .btn {
            border-radius: 0.5rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease-in-out;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--accent);
            color: var(--background);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--primary-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--border-color);
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--primary-text);
        }

        .btn-danger:hover:not(:disabled) {
             background-color: #C53030;
        }

        /* Make modal backdrop visible by default for standalone page */
        .modal-backdrop {
            display: flex; /* Changed from none */
            position: fixed;
            z-index: 50;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
            padding: 0;
        }

        .modal-content {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
            position: relative;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .loader {
            border: 2px solid #333;
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Carousel Styles */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: rgba(17, 17, 17, 0.7);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: flex; /* Always display for proper alignment, hide via JS */
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .carousel-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .carousel-btn:hover {
            background-color: var(--input-bg);
        }
        .carousel-prev { left: -0.75rem; }
        .carousel-next { right: -0.75rem; }

        .horizontal-scroll-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            gap: 1rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            /* Hide scrollbars */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex: 0 0 85%; /* Default item width */
            width: 85%;
            scroll-snap-align: center;
            white-space: normal;
        }
        /* Centering padding */
        .horizontal-scroll-container::before,
        .horizontal-scroll-container::after {
            content: '';
            width: calc((100% - 85%) / 2 - 0.5rem);
            flex-shrink: 0;
        }

        /* Wider items for scanner carousels */
        .scanner-carousel .scroll-item {
            flex: 0 0 95%; /* Make scanner items wider */
            width: 95%;
            scroll-snap-align: start; /* Align to start for better visibility */
        }
        .scanner-carousel::before,
        .scanner-carousel::after {
            width: calc((100% - 95%) / 2 - 0.5rem);
        }
        .hidden { display: none; }
    </style>
</head>
<body class="antialiased">

     <script>
        // Apply theme immediately
        (function() {
            const theme = localStorage.getItem('fitTrackAI_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>

    <!-- AI Scanner Modal Structure (Made visible by default) -->
    <div id="ai-scanner-modal" class="modal-backdrop" style="z-index: 60; display: flex;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">AI Scanner</h2>
                <button id="close-ai-scanner-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div class="space-y-4">
                <div id="ai-scanner-initial-options" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <label for="ai-upload-photo-input" class="btn btn-secondary cursor-pointer"><i data-lucide="upload"></i>Upload</label>
                    <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                    <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Live Camera</button>
                </div>
                <div id="ai-live-camera-container" class="hidden space-y-2">
                    <video id="ai-camera-video" class="w-full rounded-lg border border-border-color" autoplay playsinline></video>
                    <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames -->
                    <button id="capture-ai-photo-btn" class="btn btn-primary w-full">Capture Photo</button>
                    <button id="stop-ai-camera-btn" class="btn btn-danger w-full">Close Camera</button>
                </div>
                <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
                <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper hidden">
                    <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                    <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 min-h-[220px] !flex !flex-row !flex-nowrap">
                        <!-- Results injected here -->
                    </div>
                    <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>

    <!-- Standalone alert modal for errors -->
    <div id="alert-modal" class="modal-backdrop" style="z-index: 80; display: none;">
        <div class="modal-content">
            <h2 id="alert-modal-title" class="text-2xl font-bold mb-4">Alert</h2>
            <p id="alert-modal-text" class="text-gray-300 mb-6"></p>
            <button id="alert-modal-ok-btn" class="btn btn-primary w-full">OK</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT (Simulated - for standalone functionality) ---
            let allDailyLogs = {}; // Keep logs locally for this instance
            let viewDate = new Date(); viewDate.setHours(0,0,0,0);
            let foodCameraStream = null;
            let activeRecipeScanBtn = null; // Will be null in standalone context
            let html5QrCode = null; // Store the scanner instance
            let openModalCount = 1; // Start at 1 since the modal is shown initially

            // --- CORE & HELPER FUNCTIONS (Copied from nutrition.html) ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function getDayLog(date) {
                const key = dateToKey(date);
                if (!allDailyLogs[key]) {
                    allDailyLogs[key] = { entries: [], water: 0 };
                }
                if (typeof allDailyLogs[key].water === 'undefined') {
                     allDailyLogs[key].water = 0;
                }
                return allDailyLogs[key];
            }

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                 const apiKey = ""; // Leave empty for Canvas environment
                 return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                           // Check for expected data in the response structure
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                                // Continue retrying if format is wrong, unless last attempt
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry on rate limit or server errors
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; // Exponential backoff with jitter
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            throw new Error(`API Error: ${response.status} - ${await response.text()}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // --- Modal show/hide functions (Simplified for standalone) ---
            function showModal(modalElement) {
                modalElement.style.display = 'flex';
                // No body overflow management needed for standalone popup
                openModalCount++;
            }
            function hideModal(modalElement) {
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                     // Optionally close the window/tab if it's the last modal
                     // window.close(); // Consider if this behavior is desired
                     openModalCount = 0; // Failsafe
                }
            }

            // Simple alert function using the alert modal
            function showCustomAlert(title, text) {
                const alertModal = document.getElementById('alert-modal');
                if (alertModal.style.display === 'flex') return;
                document.getElementById('alert-modal-title').textContent = title;
                document.getElementById('alert-modal-text').textContent = text;
                showModal(alertModal);
            }

            // --- UI ELEMENT DEFINITIONS (Scoped to this file) ---
            const ui = {
                foodScannerModal: document.getElementById('ai-scanner-modal'),
                closeFoodScannerModalBtn: document.getElementById('close-ai-scanner-modal-btn'),
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),
                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),
                alertModal: document.getElementById('alert-modal'), // Added alert modal elements
                alertModalTitle: document.getElementById('alert-modal-title'),
                alertModalText: document.getElementById('alert-modal-text'),
                alertModalOkBtn: document.getElementById('alert-modal-ok-btn')
            };

            // --- SCANNER FUNCTIONS (Copied & adapted) ---

            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     console.warn(`Carousel setup failed for ${containerId}. Missing elements.`);
                     return;
                }

                const updateCarouselButtons = () => {
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;
                    prevBtn.classList.toggle('visible', scrollLeft > 10);
                    // Only show next button if there is scrollable content beyond the current view
                    nextBtn.classList.toggle('visible', scrollLeft < scrollWidth - clientWidth - 10);
                };

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    // Calculate scroll based on one item width + gap (1rem = 16px)
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => { container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' }); };
                nextBtn.onclick = () => { container.scrollBy({ left: scrollAmount(), behavior: 'smooth' }); };
                container.addEventListener('scroll', updateCarouselButtons);
                // Initial check after content might have been added
                setTimeout(updateCarouselButtons, 100); 
                // Force scroll to the newly added item (right-most)
                container.scrollLeft = container.scrollWidth;
            }
            
            // NEW FUNCTION: Reset the scanner UI state
            function resetScannerUI() {
                ui.scannerResultsContainer.innerHTML = '';
                ui.foodScannerCarouselWrapper.classList.add('hidden');
                ui.foodScannerStatus.textContent = '';
                // Ensure camera is stopped if it was running
                stopAiCamera();
                // Reset the file input value so 'change' event fires even if the same file is selected again
                ui.uploadPhotoInput.value = '';
            }

            function fileToGenerativePart(file) {
                 return new Promise((resolve, reject) => {
                     const reader = new FileReader();
                     reader.onloadend = () => {
                         const base64Data = reader.result.split(',')[1];
                         resolve({ inlineData: { mimeType: file.type, data: base64Data } });
                     };
                     reader.onerror = (err) => reject(err);
                     reader.readAsDataURL(file);
                 });
            }

            async function getAiImageClassification(imagePart) {
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error';
                }
            }

           async function processBarcodeScan(decodedText, file, resultElement) {
                const imageUrl = URL.createObjectURL(file);
                resultElement.querySelector('img').src = imageUrl;
                resultElement.querySelector('img').onerror = function() { this.onerror=null; this.src='https://placehold.co/300x150/191919/FFFFFF?text=No+Image'; };
                resultElement.querySelector('.loader')?.classList.remove('hidden');

                try {
                    // Using Open Food Facts API
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');

                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                     if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                         const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                         if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';

                    const detailsContainer = document.createElement('div');
                    detailsContainer.innerHTML = `
                        <p class="font-bold whitespace-normal">${productName}</p>
                        <p class="text-xs text-gray-400 mb-3">Barcode: ${decodedText}</p>
                        <div class="flex items-center gap-2">
                            <input type="number" value="${defaultGrams.toFixed(0)}" class="form-input !py-1.5 text-center barcode-grams-input" min="0">
                            <span class="text-gray-400">grams</span>
                        </div>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full data-log-button';
                    logButton.textContent = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    const gramsInput = detailsContainer.querySelector('.barcode-grams-input');

                    logButton.onclick = () => {
                        const grams = parseFloat(gramsInput.value);
                        if (isNaN(grams) || grams <= 0) {
                            gramsInput.classList.add('!border-red-500');
                            setTimeout(() => gramsInput.classList.remove('!border-red-500'), 1500);
                            return;
                        }

                        if (logButton.isLogged) {
                            // UNLOG (locally for this popup instance)
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                // No saveData() or updateDayView() needed in standalone
                                console.log("Removed log locally:", logButton.logId);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                            gramsInput.disabled = false;
                        } else {
                            // LOG (locally for this popup instance)
                            const logId = Date.now();
                            const ratio = grams / 100.0;
                            const foodItem = {
                                logId: logId, name: productName, brand: product.brands || '', servings: 1, grams: grams,
                                calories: (per100g.calories * ratio) || 0, protein: (per100g.protein * ratio) || 0,
                                carbs: (per100g.carbs * ratio) || 0, fat: (per100g.fat * ratio) || 0,
                                sugar: (per100g.sugar * ratio) || 0, sodium: (per100g.sodium * ratio) || 0,
                                potassium: (per100g.potassium * ratio) || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem);
                            // No saveData() or updateDayView() needed in standalone
                            console.log("Logged locally:", foodItem);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            gramsInput.disabled = true;

                            // No recipe population logic needed in standalone
                        }
                    };

                    resultElement.querySelector('.loader')?.remove();
                    resultElement.appendChild(detailsContainer);
                    resultElement.appendChild(logButton);
                    lucide.createIcons(); // Render icons if any are added

                } catch (error) {
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                }
            }


            async function startAiCamera() {
                ui.foodScannerInitialOptions.classList.add('hidden');
                ui.liveCameraContainer.classList.remove('hidden');
                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = 'Could not access camera.';
                    stopAiCamera(); // Stop camera if failed
                }
            }

            function stopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                }
                foodCameraStream = null;
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                // The status text is handled by resetScannerUI if it was called before starting the camera
                // or after processing/closing the modal.
                // ui.foodScannerStatus.textContent = ''; // Removed: Handled by resetScannerUI
                // Ensure html5QrCode scanner is stopped if it was running
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop().catch(err => console.error("Error stopping barcode scanner:", err));
                }
            }

            function captureAiPhoto() {
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                if (!video.videoWidth || !video.videoHeight) {
                    showCustomAlert("Error", "Camera stream not ready. Please try again.");
                    return;
                }
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    } else {
                        showCustomAlert("Error", "Could not capture image from camera.");
                    }
                }, 'image/jpeg', 0.9);
            }

            async function processFoodImageAI(imagePart, resultElement) {
                resultElement.querySelector('.loader')?.classList.remove('hidden'); // Show loader
                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    resultElement.querySelector('.loader')?.remove();

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'text-xs text-gray-400 whitespace-normal';

                    detailsDiv.innerHTML = `
                        <p class="font-bold text-sm text-white mb-1">${capitalizeWords(data.name) || 'Unknown Food'} (${(data.servings || 1).toFixed(1)} serv.)</p>
                        <p>${data.totalGrams?.toFixed(0) || '?'}g | ${data.calories?.toFixed(0) || '?'} kcal</p>
                        <p>${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full';
                    logButton.innerHTML = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    logButton.onclick = () => {
                         const servings = data.servings || 1;
                         const grams = data.totalGrams || 0;
                         const perServingGrams = servings > 0 ? grams / servings : 0;

                        if (logButton.isLogged) {
                            // UNLOG (locally)
                            const logIndex = getDayLog(viewDate).entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                getDayLog(viewDate).entries.splice(logIndex, 1);
                                console.log("Removed log locally:", logButton.logId);
                            }
                            logButton.textContent = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                        } else {
                            // LOG (locally)
                            const logId = Date.now();
                            const foodItem = {
                                logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                                servings: servings, grams: grams,
                                calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                                sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                            };
                            const dayLog = getDayLog(viewDate);
                            dayLog.entries.unshift(foodItem);
                            console.log("Logged locally:", foodItem);

                            logButton.textContent = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            // No recipe population logic
                        }
                    };
                    resultElement.appendChild(detailsDiv);
                    resultElement.appendChild(logButton);
                    lucide.createIcons(); // Render icons if any added

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                     resultElement.innerHTML += `<p class="text-red-400 text-xs">Error analyzing. ${error.message}</p>`;
                }
            }

            async function classifyAndProcessImage(file, resultElement) {
                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            if (!html5QrCode) {
                                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
                            }
                            // Attempt local scan first
                            const decodedText = await html5QrCode.scanFile(file, false);
                            await processBarcodeScan(decodedText, file, resultElement);
                        } catch (err) {
                             console.warn("Local barcode scan failed, falling back to food AI:", err);
                             // If local barcode fails, try classifying as food instead
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement);
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement);
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                     console.error("Image Processing Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                } finally {
                     resultElement.querySelector('.loader')?.remove(); // Ensure loader removed on error too
                }
            }


            function handleAiScanFiles(files) {
                if (!files || files.length === 0) return;
                ui.foodScannerCarouselWrapper.classList.remove('hidden');

                const filesArray = Array.from(files);

                for(const file of filesArray) {
                    const resultElement = document.createElement('div');
                    resultElement.className = 'scroll-item p-4 bg-input-bg rounded-lg text-center !flex-shrink-0'; // Ensure shrink-0

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        resultElement.innerHTML = `
                            <img src="${e.target.result}" class="w-full h-24 object-cover rounded-md mb-2">
                            <div class="loader mx-auto hidden"></div>
                        `;
                        classifyAndProcessImage(file, resultElement); // Process after setting initial HTML
                    };
                     reader.onerror = () => {
                        resultElement.innerHTML = `<p class="text-red-400 text-xs">Error reading file.</p>`;
                    };
                    reader.readAsDataURL(file);
                    ui.scannerResultsContainer.appendChild(resultElement);
                }
                 // Re-setup carousel after adding items
                 setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            }


            // --- EVENT LISTENERS (Scoped) ---
            ui.closeFoodScannerModalBtn.addEventListener('click', () => {
                resetScannerUI(); // Use the unified reset function
                hideModal(ui.foodScannerModal);
            });

            // Use the unified reset function before starting the camera
            ui.startFoodCameraBtn.addEventListener('click', () => {
                resetScannerUI(); 
                // Now start the camera
                startAiCamera();
            });

            ui.stopFoodCameraBtn.addEventListener('click', stopAiCamera);
            
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);

            // Use the unified reset function before processing uploads
            ui.uploadPhotoInput.addEventListener('change', (e) => {
                resetScannerUI(); 
                handleAiScanFiles(e.target.files);
            });

            // Alert modal OK button
             ui.alertModalOkBtn.addEventListener('click', () => hideModal(ui.alertModal));

            // --- INITIALIZATION ---
            lucide.createIcons();
            // Initialize html5QrCode scanner instance
            if (!html5QrCode) {
                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
            }
            // Setup the carousel immediately (will be called again after content is added)
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
        });
    </script>
</body>
</html>
