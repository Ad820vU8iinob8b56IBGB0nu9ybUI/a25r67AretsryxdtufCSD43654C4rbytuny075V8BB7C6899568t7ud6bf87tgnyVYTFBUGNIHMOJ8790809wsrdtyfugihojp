<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Food Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning --><script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        /* Dark theme is the default */
        :root {
            --background: #000000;
            --primary-text: #eaeaea;
            --secondary-text: #888888;
            --card-bg: #111111;
            --input-bg: #191919;
            --border-color: #222222;
            --accent: #FFFFFF;
            --accent-hover: #DDDDDD;
            --danger: #E53E3E;
            --edit: #3b82f6;
        }

        /* Light theme overrides */
        [data-theme="light"] {
            --background: #f8fafc; /* slate-50 */
            --primary-text: #0f172a; /* slate-900 */
            --secondary-text: #64748b; /* slate-500 */
            --card-bg: #ffffff;
            --input-bg: #f1f5f9; /* slate-100 */
            --border-color: #e2e8f0; /* slate-200 */
            --accent: #0f172a; /* slate-900 */
            --accent-hover: #334155; /* slate-700 */
        }


        html, body {
            overscroll-behavior-y: contain;
        }

        body {
            background-color: var(--background);
            color: var(--primary-text);
            font-family: 'Manrope', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .content-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        /* RE-ADDED from original file for the grams input */
        .form-input, .form-select {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--primary-text);
            padding: 0.75rem 1rem;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent);
        }

        .btn {
            border-radius: 0.5rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease-in-out;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--accent);
            color: var(--background);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--accent-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--primary-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--border-color);
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--primary-text);
        }

        .btn-danger:hover:not(:disabled) {
             background-color: #C53030;
        }

        /* NEW: Styles for video overlay buttons */
        .btn-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--primary-text); /* Force light text */
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        .btn-overlay:hover:not(:disabled) {
            /* MODIFIED: Changed to a neutral dark hover */
            background-color: rgba(0, 0, 0, 0.85); 
            transform: translateY(0); /* Override default btn hover */
        }

        /* NEW: Rules for danger buttons */
        .btn-overlay.btn-overlay-danger {
            background-color: rgba(229, 62, 62, 0.7); /* Red base color */
        }
        
        .btn-overlay.btn-overlay-danger:hover:not(:disabled) {
            background-color: rgba(229, 62, 62, 0.9); /* Darker red hover */
        }

        /* NEW: Set z-index for overlay buttons higher than carousel nav */
        .btn-overlay {
            z-index: 20;
        }
        
        /* NEW: Styles for the item overlay content */
        .item-overlay-content {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            /* MODIFIED: Made gradient more solid at the bottom */
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.8) 40%, rgba(0, 0, 0, 0) 100%);
            backdrop-filter: blur(4px); /* Kept blur */
            -webkit-backdrop-filter: blur(4px);
            /* RE-ADD: Rounded corners to match parent */
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
            /* MODIFIED: Reduced bottom padding */
            padding: 2.5rem 1rem 0.25rem 1rem; 
            color: var(--primary-text);
            text-align: left;
            opacity: 1; /* MODIFIED: Always visible */
            transition: opacity 0.3s ease; /* Kept transition for fade-ins if needed, but not on hover */
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            justify-content: flex-end; /* MODIFIED: Align content to bottom */
            pointer-events: auto; /* MODIFIED: Always interactive */
            z-index: 10; /* Below carousel buttons */
        }

        /* REMOVED: .scroll-item:hover .item-overlay-content rule */
        /*
        .scroll-item:hover .item-overlay-content {
            opacity: 1; 
            pointer-events: auto;
        }
        */

        .item-overlay-content p {
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            color: var(--primary-text); /* Ensure text is visible */
        }

        .item-overlay-content .item-title {
            font-weight: 600; /* font-semibold */
            /* MODIFIED: Removed margin-bottom, now handled by flex container */
            /* margin-bottom: 0.5rem; */ 
        }

        .item-overlay-content .item-nutrients {
            font-size: 0.75rem; /* text-xs */
            color: var(--secondary-text);
            /* MODIFIED: Removed margin-bottom, now handled by flex container */
            /* margin-bottom: 0.75rem; */
        }

        /* REMOVED: Full-width button style */
        /*
        .item-overlay-content .btn {
            width: 100%;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }
        */
        /* END: Item Details Overlay */
        
        /* REMOVED: Modal styles */

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .loader {
            border: 2px solid #333;
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Carousel Styles */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: rgba(17, 17, 17, 0.7);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: flex; 
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .carousel-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .carousel-btn:hover {
            background-color: var(--input-bg);
        }
        .carousel-prev { left: -0.75rem; }
        .carousel-next { right: -0.75rem; }

        .horizontal-scroll-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            gap: 1rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex: 0 0 85%; /* Default item width */
            width: 85%;
            scroll-snap-align: center;
            white-space: normal;
        }
        /* Centering padding */
        .horizontal-scroll-container::before,
        .horizontal-scroll-container::after {
            content: '';
            width: calc((100% - 85%) / 2 - 0.5rem);
            flex-shrink: 0;
        }

        /* Wider items for scanner carousels */
        .scanner-carousel .scroll-item {
            flex: 0 0 95%; /* Make scanner items wider */
            width: 95%;
            scroll-snap-align: start; /* Align to start for better visibility */
        }
        .scanner-carousel::before,
        .scanner-carousel::after {
            width: calc((100% - 95%) / 2 - 0.5rem);
        }
    </style>
</head>
<body class="antialiased">

     <script>
         // Apply theme immediately
         (function() {
             const theme = localStorage.getItem('fitTrackAI_theme') || 'dark';
             document.documentElement.setAttribute('data-theme', theme);
         })();
     </script>

    <!-- REMOVED "Open Scanner" Button Section --><!-- <div class="container mx-auto max-w-lg px-4 py-12 text-center"> ... </div> --><!-- NEW: AI Scanner is now embedded directly on the page --><div class="container mx-auto max-w-lg px-4 py-12">
        <div class="space-y-4">
            <!-- Removed the modal header and close button --><h2 class="text-2xl font-bold mb-6 text-center">AI Scanner</h2>
            
            <!-- This container is no longer needed here --><!-- <div id="ai-live-camera-container" class="relative"> ... </div> --><p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
            
            <!-- MODIFIED: Wrapper is no longer hidden by default --><div id="ai-scanner-carousel-wrapper" class="carousel-wrapper">
                <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                
                <!-- MODIFIED: Container now holds the camera AND results. min-h-[300px] is removed for h-96 items. --><div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 !flex !flex-row !flex-nowrap">
                    
                    <!-- Results injected here --><!-- MODIFIED: "Start Camera" button is now SECOND-TO-LAST item --><div id="ai-scanner-initial-options" class="scroll-item h-96 !flex-shrink-0 flex flex-col items-center justify-center p-4 bg-input-bg rounded-lg hidden">
                        <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Start Camera</button>
                    </div>

                    <!-- NEW: ADDED BACK THE MISSING LIVE CAMERA CONTAINER --><div id="ai-live-camera-container" class="scroll-item h-96 !flex-shrink-0 bg-input-bg rounded-lg relative overflow-hidden">
                        <video id="ai-camera-video" class="w-full h-full object-cover" autoplay playsinline muted></video>
                        <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames --><!-- Top-left button: Stop Camera (REMOVED) --><!-- 
                        <button id="stop-ai-camera-btn" class="btn btn-overlay btn-overlay-danger !p-2 !rounded-full absolute top-3 left-3" title="Close Camera">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button> 
                        --><!-- Bottom-left button: Log All --><button id="log-all-scanned-btn" class="btn btn-overlay !p-2 !rounded-full absolute bottom-3 left-3" title="Log All New Items">
                            <i data-lucide="check-check" class="w-5 h-5"></i>
                        </button>

                        <!-- Bottom-center button: Capture --><div class="absolute bottom-3 left-1/2 -translate-x-1/2 z-20 flex items-center gap-2">
                            <button id="capture-ai-photo-btn" class="btn btn-overlay !p-2 !rounded-full" title="Capture Photo">
                                <i data-lucide="camera" class="w-5 h-5"></i>
                            </button>
                            <!-- MOVED: Stop Camera button --><button id="stop-ai-camera-btn" class="btn btn-overlay btn-overlay-danger !p-2 !rounded-full" title="Close Camera">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>
                        
                        <!-- Bottom-right button: Upload --><label for="ai-upload-photo-input" class="btn btn-overlay !p-2 !rounded-full absolute bottom-3 right-3 cursor-pointer" title="Upload Photo">
                            <i data-lucide="upload" class="w-5 h-5"></i>
                        </label>
                        <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                    </div>
                    <!-- END: ADDED BACK CAMERA CONTAINER --></div>
                <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
            </div>
        </div>
    </div>

    <!-- NEW: ADDED BACK LOGGED ITEMS DISPLAY --><div class="container mx-auto max-w-lg px-4 py-6 text-left">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">Today's Scanned Items</h2>
            <a href="nutrition.html" class="btn btn-secondary !p-2 text-xs">
                <i data-lucide="pie-chart" class="w-4 h-4"></i>
                View Nutrition
            </a>
        </div>
        <div id="scanned-log-display" class="space-y-2">
            <p class="text-secondary-text">No items scanned and logged yet.</p>
        </div>
    </div>
    <!-- END: ADDED BACK LOGGED ITEMS DISPLAY --><!-- REMOVED: Item Details Modal --><!--
    <div id="item-details-modal" class="modal-backdrop" style="z-index: 60;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">Item Details</h2>
                <button id="close-item-details-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="item-details-content" class="min-h-[100px] flex items-center justify-center">
                <div class="loader mx-auto"></div>
            </div>
        </div>
    </div>
    --><!-- Hidden helper for html5-qrcode library --><div id="barcode-reader-hidden-helper" class="hidden"></div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let foodCameraStream = null;
            let html5QrCode = null;

            // --- NEW: Local log state ---
            let scannerLogs = {};
            let viewDate = new Date();
            viewDate.setHours(0, 0, 0, 0);
            // --- END: Local log state ---

            // --- UI ELEMENT DEFINITIONS ---
            const ui = {
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),
                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),
                scannedLogDisplay: document.getElementById('scanned-log-display'),
                logAllBtn: document.getElementById('log-all-scanned-btn'),
                // REMOVED: Item details modal elements
                // itemDetailsModal: document.getElementById('item-details-modal'),
                // itemDetailsContent: document.getElementById('item-details-content'),
                // closeItemDetailsModalBtn: document.getElementById('close-item-details-modal-btn'),
            };

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                 const apiKey = ""; // Leave empty for Canvas environment
                 return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            throw new Error(`API Error: ${response.status} - ${await response.text()}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // REMOVED: Modal show/hide functions
            // function showModal(modalElement) { ... }
            // function hideModal(modalElement) { ... }
            // --- END Modal functions ---

            // --- Helper Functions ---
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     console.warn(`Carousel setup failed for ${containerId}. Missing elements.`);
                     return;
                }

                const updateCarouselButtons = () => {
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;
                    
                    // NEW: Check how many items are visible
                    const visibleItems = container.querySelectorAll('.scroll-item:not(.hidden)').length;

                    prevBtn.classList.toggle('visible', scrollLeft > 10 && visibleItems > 1);
                    nextBtn.classList.toggle('visible', scrollLeft < scrollWidth - clientWidth - 10 && visibleItems > 1);
                };

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => {
                    container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' });
                };

                nextBtn.onclick = () => {
                    container.scrollBy({ left: scrollAmount(), behavior: 'smooth' });
                };

                container.addEventListener('scroll', updateCarouselButtons);
                setTimeout(updateCarouselButtons, 100);
            }

            function fileToGenerativePart(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => { const base64Data = reader.result.split(',')[1]; resolve({ inlineData: { mimeType: file.type, data: base64Data } }); }; reader.onerror = (err) => reject(err); reader.readAsDataURL(file); }); }


            // --- NEW: Local Log Functions ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }

            function getTodaysLog() {
                const key = dateToKey(viewDate);
                if (!scannerLogs[key]) {
                    scannerLogs[key] = { entries: [] };
                }
                return scannerLogs[key];
            }

            function saveScannerLog() {
                localStorage.setItem('scannerAI_logs', JSON.stringify(scannerLogs));
            }

            function loadScannerLog() {
                scannerLogs = JSON.parse(localStorage.getItem('scannerAI_logs')) || {};
            }

            function renderScannerLog() {
                const dayLog = getTodaysLog();
                if (dayLog.entries.length === 0) {
                    ui.scannedLogDisplay.innerHTML = '<p class="text-secondary-text">No items scanned and logged yet.</p>';
                    return;
                }

                ui.scannedLogDisplay.innerHTML = dayLog.entries.map((item, index) => `
                    <div class="bg-card-bg border border-border-color p-3 rounded-lg flex justify-between items-center">
                        <div>
                            <p class="font-medium">${item.servings}x ${item.name} ${item.grams > 0 ? `(${item.grams.toFixed(0)}g)` : ''}</p>
                            <p class="text-sm text-secondary-text">${item.calories?.toFixed(0) || 0}kcal | ${item.protein?.toFixed(1) || 0}p | ${item.carbs?.toFixed(1) || 0}c | ${item.fat?.toFixed(1) || 0}f</p>
                        </div>
                        <button class="btn btn-danger !p-2 remove-log-btn" data-log-id="${item.logId}" title="Remove">
                            <i data-lucide="trash-2" class="w-4 h-4 pointer-events-none"></i>
                        </button>
                    </div>
                `).join('');
                
                lucide.createIcons(); // Moved inside to render new icons
                
            } 

            /* REMOVED: checkLogAllButtonVisibility function */
            
            // --- Scanner Core Functions ---

            async function getAiImageClassification(imagePart) {
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error';
                }
            }

           // MODIFIED: Takes resultElement directly
           async function processBarcodeScan(decodedText, file, resultElement) {
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (!overlayContent) return;

                // Show loader within the overlay
                overlayContent.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');

                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                    if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                         const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                         if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';

                    // --- NEW: Auto-log logic ---
                    const logId = Date.now();
                    const servings = 1;
                    const grams = defaultGrams;
                    const foodItem = {
                        logId: logId, name: productName, brand: product.brands || '',
                        servings: servings, grams: grams,
                        calories: (per100g.calories / 100 * grams) || 0, 
                        protein: (per100g.protein / 100 * grams) || 0, 
                        carbs: (per100g.carbs / 100 * grams) || 0, // <-- Fixed bug from per100g.carbohydrates
                        fat: (per100g.fat / 100 * grams) || 0,
                        sugar: (per100g.sugar / 100 * grams) || 0, 
                        sodium: (per100g.sodium / 100 * grams) || 0, 
                        potassium: (per100g.potassium / 100 * grams) || 0,
                    };
                    const dayLog = getTodaysLog();
                    dayLog.entries.unshift(foodItem);
                    saveScannerLog();
                    renderScannerLog();
                    // --- END: Auto-log logic ---

                    overlayContent.innerHTML = `
                        <div>
                            <div class="flex justify-between items-start gap-2">
                                <div>
                                    <p class="item-title">${productName} (est. ${defaultGrams.toFixed(0)}g)</p>
                                    <p class="item-nutrients">${per100g.calories.toFixed(0)} kcal | ${per100g.protein.toFixed(1)}p | ${per100g.carbs.toFixed(1)}c | ${per100g.fat.toFixed(1)}f</p>
                                </div>
                                <!-- MODIFIED: Default to logged state (btn-secondary, check-check, logId) -->
                                <button class="btn btn-secondary ai-log-button !p-2 !rounded-full !flex-shrink-0" data-log-id="${logId}" title="Logged! (Tap to undo)">
                                    <i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    lucide.createIcons({ root: overlayContent }); // Render the new icon
                    
                    const logButton = overlayContent.querySelector('.ai-log-button');
                    
                    // --- NEW: Set initial state for the button ---
                    logButton.isLogged = true;
                    logButton.logId = logId;

                    logButton.onclick = () => {
                        const servings = 1; // Assuming 1 serving for a scanned item unless more sophisticated logic
                        const grams = defaultGrams;

                        if (logButton.isLogged) {
                            const dayLog = getTodaysLog();
                            const logIndex = dayLog.entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                dayLog.entries.splice(logIndex, 1);
                                saveScannerLog();
                                renderScannerLog();
                            }
                            logButton.innerHTML = '<i data-lucide="check" class="w-4 h-4 pointer-events-none"></i>';
                            logButton.title = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                            lucide.createIcons({ root: logButton }); // Re-render icon
                        } else {
                            const logId = Date.now();
                            const foodItem = {
                                logId: logId, name: productName, brand: product.brands || '',
                                servings: servings, grams: grams,
                                calories: (per100g.calories / 100 * grams) || 0, 
                                protein: (per100g.protein / 100 * grams) || 0, 
                                carbs: (per100g.carbs / 100 * grams) || 0, // <-- Fixed bug from per100g.carbohydrates
                                fat: (per100g.fat / 100 * grams) || 0,
                                sugar: (per100g.sugar / 100 * grams) || 0, 
                                sodium: (per100g.sodium / 100 * grams) || 0, 
                                potassium: (per100g.potassium / 100 * grams) || 0,
                            };
                            const dayLog = getTodaysLog();
                            dayLog.entries.unshift(foodItem);
                            saveScannerLog();
                            renderScannerLog();

                            logButton.innerHTML = '<i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>';
                            logButton.title = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            lucide.createIcons({ root: logButton }); // Re-render icon
                        }
                    };

                } catch (error) {
                    const errorMsg = `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                    overlayContent.innerHTML = errorMsg;
                }
            }

            // NEW: Auto-stop function for observer
            function autoStopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                    foodCameraStream = null;
                    ui.foodScannerStatus.textContent = 'Camera paused. Scroll back to resume.';
                }
            }

            // MODIFIED: Renamed from stopAiCamera
            function manualStopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                    foodCameraStream = null;
                }
                // This part shows the "Start" card
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                setTimeout(() => {
                    ui.foodScannerInitialOptions.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }, 100);
                ui.foodScannerStatus.textContent = '';
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop().catch(err => console.error("Error stopping barcode scanner:", err));
                }
            }

            async function startAiCamera() {
                // MODIFIED: This function is now more robust.
                
                // If the "Start" card is visible, hide it.
                if (!ui.foodScannerInitialOptions.classList.contains('hidden')) {
                    ui.foodScannerInitialOptions.classList.add('hidden');
                }
                
                // Always make sure the camera container is visible.
                ui.liveCameraContainer.classList.remove('hidden');

                // If stream already exists, just scroll to it and exit.
                // This handles the seamless observer logic.
                if (foodCameraStream) {
                    setTimeout(() => {
                        ui.liveCameraContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }, 100);
                    return;
                }

                // If we're here, the stream doesn't exist and we need to start it.
                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                    // MODIFIED: Scroll to camera view after it starts
                    setTimeout(() => {
                        ui.liveCameraContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }, 100); // Small delay for rendering
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = 'Could not access camera.';
                    manualStopAiCamera(); // Use manual stop to show "Start" button
                }
            }

            /* MODIFIED: Renamed stopAiCamera to manualStopAiCamera */
            // function stopAiCamera() { ... }

            function captureAiPhoto() {
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    }
                }, 'image/jpeg', 0.9);
            }

            // MODIFIED: Takes resultElement directly
            async function processFoodImageAI(imagePart, resultElement) {
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (!overlayContent) return;

                // Show loader within the overlay
                overlayContent.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    
                    // --- NEW: Auto-log logic ---
                    const logId = Date.now();
                    const servings = data.servings || 1;
                    const grams = data.totalGrams || 0;
                    const foodItem = {
                        logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                        servings: servings, grams: grams,
                        calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                        sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                    };
                    const dayLog = getTodaysLog();
                    dayLog.entries.unshift(foodItem);
                    saveScannerLog();
                    renderScannerLog();
                    // --- END: Auto-log logic ---
                    
                    overlayContent.innerHTML = `
                        <div>
                            <div class="flex justify-between items-start gap-2">
                                <div>
                                    <p class="item-title">${capitalizeWords(data.name) || 'Unknown Food'} (${(data.servings || 1).toFixed(1)} serv.)</p>
                                    <p class="item-nutrients">${data.calories?.toFixed(0) || '?'} kcal | ${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                                </div>
                                <!-- MODIFIED: Default to logged state (btn-secondary, check-check, logId) -->
                                <button class="btn btn-secondary ai-log-button !p-2 !rounded-full !flex-shrink-0" data-log-id="${logId}" title="Logged! (Tap to undo)">
                                    <i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    lucide.createIcons({ root: overlayContent }); // Render the new icon

                    const logButton = overlayContent.querySelector('.ai-log-button');
                    
                    // --- NEW: Set initial state for the button ---
                    logButton.isLogged = true;
                    logButton.logId = logId;

                    logButton.onclick = () => {
                        const servings = data.servings || 1;
                        const grams = data.totalGrams || 0;

                        if (logButton.isLogged) {
                            // UNLOG
                            const dayLog = getTodaysLog();
                            const logIndex = dayLog.entries.findIndex(entry => entry.logId === logButton.logId);
                            if (logIndex > -1) {
                                dayLog.entries.splice(logIndex, 1);
                                saveScannerLog();
                                renderScannerLog();
                            }
                            logButton.innerHTML = '<i data-lucide="check" class="w-4 h-4 pointer-events-none"></i>';
                            logButton.title = 'Log this';
                            logButton.classList.remove('btn-secondary');
                            logButton.classList.add('btn-primary');
                            logButton.isLogged = false;
                            logButton.logId = null;
                            lucide.createIcons({ root: logButton }); // Re-render icon
                        } else {
                            // LOG
                            const logId = Date.now();
                            const foodItem = {
                                logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                                servings: servings, grams: grams,
                                calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                                sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                            };
                            const dayLog = getTodaysLog();
                            dayLog.entries.unshift(foodItem);
                            saveScannerLog();
                            renderScannerLog();

                            logButton.innerHTML = '<i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>';
                            logButton.title = 'Logged! (Tap to undo)';
                            logButton.classList.remove('btn-primary');
                            logButton.classList.add('btn-secondary');
                            logButton.isLogged = true;
                            logButton.logId = logId;
                            lucide.createIcons({ root: logButton }); // Re-render icon
                        }
                    };

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    const errorMsg = `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                    overlayContent.innerHTML = errorMsg;
                }
            }

            // MODIFIED: Takes resultElement directly
            async function classifyAndProcessImage(file, resultElement) {
                // Initial loader is now inside the overlay
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (overlayContent) {
                    overlayContent.innerHTML = '<div class="loader mx-auto"></div>';
                }

                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            if (!html5QrCode) {
                                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
                            }
                            const decodedText = await html5QrCode.scanFile(file, false);
                            await processBarcodeScan(decodedText, file, resultElement); // Pass resultElement
                        } catch (err) {
                             console.warn("Local barcode scan failed, falling back to food AI:", err);
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement); // Pass resultElement
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement); // Pass resultElement
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                     console.error("Image Processing Error:", error);
                     const errorMsg = `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                     if (overlayContent) {
                         overlayContent.innerHTML = errorMsg;
                     }
                }
            }

            function handleAiScanFiles(files) {
                if (!files || files.length === 0) return;
                 
                const filesArray = Array.from(files);

                for(const file of filesArray) {
                    const resultElement = document.createElement('div');
                    resultElement.className = 'scroll-item bg-input-bg rounded-lg text-center !flex-shrink-0 h-96 overflow-hidden relative';

                    resultElement.innerHTML = `
                        <img class="w-full h-full object-cover" src="https://placehold.co/400x600/191919/191919?text=." alt="Scanned item placeholder">
                        <div class="item-overlay-content">
                            <!-- Loader or actual content will be injected here by classifyAndProcessImage --></div>
                    `;
                    
                    ui.scannerResultsContainer.insertBefore(resultElement, ui.foodScannerInitialOptions);

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageUrl = e.target.result;
                        const img = resultElement.querySelector('img');
img.src = imageUrl;
                        
                        // Immediately start classification and populate overlay
                        classifyAndProcessImage(file, resultElement);
                    };
                     reader.onerror = () => {
                         const overlayContent = resultElement.querySelector('.item-overlay-content');
                         if (overlayContent) {
                            overlayContent.innerHTML = `<p class="text-red-400 text-xs">Error reading file.</p>`;
                         }
                     };
                     reader.readAsDataURL(file);

                    setTimeout(() => {
                        resultElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }, 100); 
                }
                 setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            }
            
            // --- EVENT LISTENERS ---
            
            ui.startFoodCameraBtn.addEventListener('click', startAiCamera);
            ui.stopFoodCameraBtn.addEventListener('click', manualStopAiCamera);
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);
            ui.uploadPhotoInput.addEventListener('change', (e) => handleAiScanFiles(e.target.files));

            // NEW: Listener for removing items from the local log
            ui.scannedLogDisplay.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-log-btn');
                if (removeBtn) {
                    const logId = parseInt(removeBtn.dataset.logId);
                    if (isNaN(logId)) return;

                    const dayLog = getTodaysLog();
                    const logIndex = dayLog.entries.findIndex(entry => entry.logId === logId);
                    
                    if (logIndex > -1) {
                        dayLog.entries.splice(logIndex, 1);
                        saveScannerLog();
                        renderScannerLog();

                        // --- NEW: Find and update carousel button ---
                        const carouselLogButton = ui.scannerResultsContainer.querySelector(`.ai-log-button[data-log-id="${logId}"]`);
                        if (carouselLogButton) {
                            carouselLogButton.innerHTML = '<i data-lucide="check" class="w-4 h-4 pointer-events-none"></i>';
                            carouselLogButton.title = 'Log this';
                            carouselLogButton.classList.remove('btn-secondary');
                            carouselLogButton.classList.add('btn-primary');
                            carouselLogButton.isLogged = false;
                            carouselLogButton.logId = null;
                            carouselLogButton.dataset.logId = "null";
                            lucide.createIcons({ root: carouselLogButton });
                        }
                        // --- END: Find and update carousel button ---
                    }
                }
            });

            // NEW: Event listener for Log All button
            ui.logAllBtn.addEventListener('click', () => {
                // Find all un-logged buttons
                const logButtons = ui.scannerResultsContainer.querySelectorAll('.ai-log-button.btn-primary');
                let loggedCount = 0;
                logButtons.forEach(btn => {
                    btn.click(); // This will trigger the individual log logic and state change
                    loggedCount++;
                });
            }); 
            
            // REMOVED: Close item details modal event listener
            // ui.closeItemDetailsModalBtn.addEventListener('click', () => { ... });

            // NEW: Camera observer
            const cameraObserver = new IntersectionObserver((entries) => {
                const entry = entries[0];
                // Only act if the live camera card is *supposed* to be visible
                if (!ui.liveCameraContainer.classList.contains('hidden')) {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.9) {
                        // Scrolled *to* the camera. If it's not running, start it.
                        if (!foodCameraStream) {
                            startAiCamera();
                        }
                    } else if (!entry.isIntersecting && foodCameraStream) {
                        // Scrolled *away* from the camera. If it's running, stop it.
                        autoStopAiCamera();
                    }
                }
            }, { threshold: [0.1, 0.9] }); // Fire at 10% and 90% visibility

            cameraObserver.observe(ui.liveCameraContainer);
                
            // --- INITIAL LOAD ---
            loadScannerLog();
            renderScannerLog();
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            lucide.createIcons();
            
            startAiCamera(); // Start camera on load
        });
    </script>
</body>
</html>
