<!DOCTYPE html>
<html lang="en" class="h-full"> <!-- ADDED h-full -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Food Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning --><script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    
    <link rel="stylesheet" href="../styles.css">

    <style>
        html, body {
            overscroll-behavior-y: contain;
        }

        /* Styles for video overlay buttons */
        .btn-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--primary-text); /* Force light text */
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        .btn-overlay:hover:not(:disabled) {
            background-color: rgba(0, 0, 0, 0.85); 
            transform: translateY(0);
        }

        .btn-overlay.btn-overlay-danger {
            background-color: rgba(229, 62, 62, 0.7); /* Red base color */
        }
        
        .btn-overlay.btn-overlay-danger:hover:not(:disabled) {
            background-color: rgba(229, 62, 62, 0.9); /* Darker red hover */
        }

        .btn-overlay {
            z-index: 20;
        }
        
        /* MODIFIED: Item overlay for filmstrip */
        .item-overlay-content {
            position: absolute; 
            bottom: 0;
            left: 0;
            right: 0;
            /* MODIFIED: Lighter gradient for smaller card */
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            border-bottom-left-radius: 0.5rem; /* Match parent */
            border-bottom-right-radius: 0.5rem; /* Match parent */
            padding: 1.5rem 0.5rem 0.25rem 0.5rem; 
            color: var(--primary-text);
            text-align: left;
            opacity: 1;
            transition: opacity 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            pointer-events: auto;
            z-index: 10;
        }

        .item-overlay-content p {
            font-size: 0.75rem; /* text-xs */
            line-height: 1rem;
            color: var(--primary-text);
        }

        .item-overlay-content .item-title {
            font-weight: 600; /* font-semibold */
            font-size: 0.75rem; /* text-xs */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .item-overlay-content .item-nutrients {
            display: none; /* Hide nutrients on small filmstrip */
        }
        
        /* MODIFIED: Carousel Wrapper is now the filmstrip container */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            z-index: 15; /* Above camera, below buttons */
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
            margin-top: 1rem;
            /* ADDED: Ensure it doesn't shrink */
            flex-shrink: 0; 
        }

        /* REMOVED: Carousel Button Styles */

        /* MODIFIED: Horizontal scroll container for filmstrip */
        .horizontal-scroll-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            scroll-behavior: smooth;
            /* MODIFIED: Add snap type for fluid scroll */
            scroll-snap-type: x mandatory; 
            gap: 0.75rem; /* 12px */
            padding-bottom: 1rem;
            padding-left: 1rem;
            padding-right: 1rem;
            -ms-overflow-style: none;
            scrollbar-width: none;
            cursor: grab;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .horizontal-scroll-container:active {
            cursor: grabbing;
        }
        
        /* MODIFIED: Scroll item for filmstrip */
        .scroll-item {
            flex: 0 0 7rem; /* w-28 */
            width: 7rem; /* w-28 */
            height: 7rem; /* h-28 */
            scroll-snap-align: start; /* Snap to start */
            white-space: normal;
        }
        /* REMOVED: Centering padding */
        
        /* REMOVED: scanner-carousel specific styles */

        /* Custom scrollbar for the scanned items list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-text);
        }
        .custom-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: thin;  /* Firefox */
            scrollbar-color: var(--border-color) transparent;
        }

        /* --- MODIFIED: Photo Popup Styles --- */
        #photo-popup {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: scale(0.9);
            display: none; /* Hidden by default */
            /* MODIFIED: Positioned absolutely inside the camera container */
            position: absolute;
            top: 1rem; /* 4 */
            left: 1rem; /* 4 */
            z-index: 30; /* Above video, below buttons */
            width: 6rem; /* w-24 */
            height: 6rem; /* h-24 */
            border-radius: 0.5rem; /* rounded-lg */
            border-width: 2px;
            border-color: #FFFFFF; /* border-white */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-lg */
            overflow: hidden;
            opacity: 0;
        }
        #photo-popup.show {
            display: block;
            opacity: 1;
            transform: scale(1);
        }
        #photo-popup.hide {
            opacity: 0;
            transform: scale(0.9);
        }

        /* --- REMOVED: Camera Overlay Styles --- */
        /* Tailwind classes will handle this now */
        /* --- END: Camera Overlay Styles --- */

    </style>
</head>
<!-- MODIFIED: Added h-full, flex, flex-col, overflow-hidden -->
<body class="antialiased h-full flex flex-col overflow-hidden">

    <script>
        // Apply theme immediately
        (function() {
            const theme = localStorage.getItem('fitTrackAI_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
    
    <!-- REMOVED: Photo Popup Container from here -->

    <div id="header-placeholder"></div>

    <!-- Main content area, adjusted padding for header/footer -->
    <!-- MODIFIED: Removed container, max-w, margins, and padding. Added flex-grow, overflow-hidden, flex, flex-col -->
    <div class="content-card flex-grow overflow-hidden flex flex-col">
        <!-- MODIFIED: Added flex-grow, flex, flex-col, p-4 -->
        <div class="space-y-4 flex-grow flex flex-col p-4">
            
            <!-- MODIFIED: This is now the main camera view. Replaced h-96 with flex-grow -->
            <div id="ai-live-camera-container" class="!flex-shrink-0 bg-input-bg rounded-lg relative overflow-hidden flex-grow">
                
                <!-- MOVED: Photo Popup Container here -->
                <div id="photo-popup">
                    <!-- MODIFIED: Added object-cover -->
                    <img id="photo-popup-img" src="" alt="Scanned item" class="w-full h-full object-cover">
                </div>

                <!-- MODIFIED: Camera Off Overlay - Now uses canvas and Tailwind -->
                <div id="camera-overlay" class="absolute inset-0 z-20 rounded-lg overflow-hidden transition-opacity duration-300 opacity-0 pointer-events-none">
                    <!-- Canvas for last frame -->
                    <canvas id="camera-overlay-canvas" class="absolute top-0 left-0 w-full h-full object-cover"></canvas>
                    <!-- Darkening layer -->
                    <div class="absolute top-0 left-0 w-full h-full bg-black/70 backdrop-blur-sm"></div>
                    <!-- Button container -->
                    <div class="absolute top-0 left-0 w-full h-full flex items-center justify-center z-10">
                        <button id="start-camera-overlay-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Start Camera</button>
                    </div>
                </div>

                <!-- MODIFIED: Reverted to object-cover -->
                <video id="ai-camera-video" class="w-full h-full object-cover" autoplay playsinline muted></video>
                <canvas id="ai-camera-canvas" class="hidden"></canvas> 
                
                <!-- MODIFIED: Close button moved to top-right -->
                <a href="javascript:history.back()" id="scanner-close-btn" class="btn-overlay !p-4 !rounded-full absolute top-4 right-4 z-30" title="Close Scanner">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </a>
                
                <!-- ADDED: Today's Log Button -->
                <button id="scanned-log-popup-btn" class="btn-overlay !p-2 !rounded-full absolute top-4 left-4 z-30" title="Today's Log">
                    <i data-lucide="list" class="w-5 h-5"></i>
                </button>

                <!-- MODIFIED: log-all-scanned-btn replaced with flip-camera-btn -->
                <button id="flip-camera-btn" class="btn btn-overlay !p-2 !rounded-full absolute bottom-3 left-3" title="Flip Camera">
                    <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                </button>

                <div class="absolute bottom-3 left-1/2 -translate-x-1/2 z-20 flex items-center gap-2">
                    <button id="capture-ai-photo-btn" class="btn btn-overlay !p-2 !rounded-full" title="Capture Photo">
                        <i data-lucide="camera" class="w-5 h-5"></i>
                    </button>
                    <button id="stop-ai-camera-btn" class="btn btn-overlay btn-overlay-danger !p-2 !rounded-full" title="Close Camera">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <label for="ai-upload-photo-input" class="btn btn-overlay !p-2 !rounded-full absolute bottom-3 right-3 cursor-pointer" title="Upload Photo">
                    <i data-lucide="upload" class="w-5 h-5"></i>
                </label>
                <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
            </div>
            
            <!-- MOVED: ai-scanner-status is now at the bottom of this card -->
            
            <!-- MODIFIED: Carousel wrapper is now the filmstrip -->
            <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper">
                <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel !flex !flex-row !flex-nowrap">
                    <!-- Scanned items will be prepended here by JS -->
                </div>
            </div>
            
            <!-- MOVED: ai-scanner-status is here -->
            <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem] mt-4 flex-shrink-0"></p> <!-- ADDED flex-shrink-0 -->
        </div>
    </div>

    <!-- REMOVED: Today's Scanned Items section from here -->

    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>
    
    <!-- --- ADDED: Undo Toast --- -->
    <div id="undo-toast" class="fixed bottom-20 left-1/2 -translate-x-1/2 transform opacity-0 transition-all duration-300 z-[100]
                        bg-input-bg border border-border-color rounded-lg shadow-lg flex items-center gap-4 py-3 px-4">
        <span id="undo-toast-text" class="text-sm text-primary-text">Item removed.</span>
        <button id="undo-toast-btn" class="font-semibold text-blue-400 hover:text-blue-300 text-sm">Undo</button>
    </div>

    <!-- ADDED: Scanned Log Modal -->
    <div id="scanned-log-modal" class="modal-backdrop" style="z-index: 1001;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Today's Scanned Items</h2>
                <button id="close-scanned-log-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="scanned-log-display" class="space-y-2 max-h-96 overflow-y-auto custom-scrollbar pr-1">
                <p class="text-secondary-text">No items scanned and logged yet.</p>
            </div>
            <button id="scanned-log-modal-ok-btn" class="btn btn-primary w-full mt-6">Close</button>
        </div>
    </div>
    <!-- END: Scanned Log Modal -->


    <div id="footer-placeholder"></div>

    <script>
        // --- Load Header and Footer ---
        async function loadComponent(url, placeholderId) {
            // ... (existing loadComponent function) ...
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}: ${response.statusText}`);
                let text = await response.text();
                
                text = text.replace(/href="index\.html"/g, 'href="../../index.html"');
                text = text.replace(/href="settings\.html"/g, 'href="../../settings.html"');
                text = text.replace(/href="nutrition\.html"/g, 'href="../../nutrition.html"');
                text = text.replace(/href="workouts\.html"/g, 'href="../../workouts.html"');
                text = text.replace(/href="sleep\.html"/g, 'href="../../sleep.html"');
                text = text.replace(/href="progress\.html"/g, 'href="../../progress.html"');
                text = text.replace(/href="social\.html"/g, 'href="../../social.html"');

                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = text;
                }
            } catch (error) {
                console.error(`Error loading component from ${url}:`, error);
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = `<p class="text-red-500 text-center">Error loading component.</p>`;
                }
            }
        }

        async function initializeLayout() {
            // ... (existing initializeLayout function) ...
            await Promise.all([
                loadComponent('../header.html', 'header-placeholder'),
                loadComponent('../footer.html', 'footer-placeholder')
            ]);
            lucide.createIcons(); 

            const currentPage = 'nutrition';
            const navLinks = document.querySelectorAll('#mobile-footer-nav .nav-link');
            navLinks.forEach(link => {
                const linkPage = link.getAttribute('data-page');
                if (linkPage === currentPage) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });

            initializeAppPage();
        }
        // --- End Load Header and Footer ---

        // --- Original page script wrapped in a function ---
        function initializeAppPage() {
            let foodCameraStream = null;
            let html5QrCode = null;
            // ADDED: Camera facing mode state
            let currentFacingMode = 'environment';

            let scannerLogs = {};
            let viewDate = new Date();
            viewDate.setHours(0, 0, 0, 0);

            let isDragging = false;
            let dragStartX = 0;
            // MODIFIED: Reverted drag logic
            let scrollLeftStart = 0;
            let dragDeltaX = 0;
            
            // --- MODIFIED: Added variables for new drag logic ---
            let currentTranslate = 0;
            let startTranslate = 0;
            let animationFrameId = null;

            // --- ADDED: Undo Toast State ---
            let undoTimeout = null;
            let lastAction = null;
            // --- END: Undo Toast State ---

            const ui = {
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),
                // REMOVED: foodScannerInitialOptions
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                // ADDED: cameraOverlay and startCameraOverlayBtn
                cameraOverlay: document.getElementById('camera-overlay'),
                startCameraOverlayBtn: document.getElementById('start-camera-overlay-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                // REMOVED foodScannerPrev and foodScannerNext from UI object
                scannedLogDisplay: document.getElementById('scanned-log-display'),
                // MODIFIED: logAllBtn -> flipCameraBtn
                flipCameraBtn: document.getElementById('flip-camera-btn'),
                // --- ADDED: Undo Toast UI ---
                undoToast: document.getElementById('undo-toast'),
                undoToastText: document.getElementById('undo-toast-text'),
                undoToastBtn: document.getElementById('undo-toast-btn'),
                // --- ADDED: Photo Popup UI ---
                photoPopup: document.getElementById('photo-popup'),
                photoPopupImg: document.getElementById('photo-popup-img'),
                // --- ADDED: Scanned Log Modal UI ---
                scannedLogPopupBtn: document.getElementById('scanned-log-popup-btn'),
                scannedLogModal: document.getElementById('scanned-log-modal'),
                closeScannedLogModalBtn: document.getElementById('close-scanned-log-modal-btn'),
                scannedLogModalOkBtn: document.getElementById('scanned-log-modal-ok-btn'),
            };

            const getApiUrl = (model, action = 'generateContent') => {
                const apiKey = "AIzaSyA8-WLMo2U2Km-FN2r_fYk8OUfxyZ7dJoM"; // Leave empty for Canvas environment
                return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                // ... (existing fetchWithBackoff function) ...
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result;
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                            }
                        } else if (response.status === 429 || response.status >= 500) {
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw new Error(`API Error: ${response.status} - ${await response.text()}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error;
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }

            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            // --- ADDED: Modal Show/Hide ---
            let openModalCount = 0;
            function showModal(modalElement) {
                if (!modalElement) return;
                modalElement.style.display = 'flex';
                if (openModalCount === 0) {
                    // document.body.style.overflow = 'hidden'; // Body overflow is already hidden
                }
                openModalCount++;
            }
            function hideModal(modalElement) {
                if (!modalElement) return;
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                    // document.body.style.overflow = '';
                    openModalCount = 0; // Failsafe
                }
            }
            // --- END: Modal Show/Hide ---

            // REMOVED setupCarousel function
            function fileToGenerativePart(file) { 
                // ... (existing fileToGenerativePart function) ...
                return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => { const base64Data = reader.result.split(',')[1]; resolve({ inlineData: { mimeType: file.type, data: base64Data } }); }; reader.onerror = (err) => reject(err); reader.readAsDataURL(file); }); 
            }

            function dateToKey(date) { 
                // ... (existing dateToKey function) ...
                return date.toISOString().split('T')[0]; 
            }

            function getTodaysLog() {
                // ... (existing getTodaysLog function) ...
                const key = dateToKey(viewDate);
                if (!scannerLogs[key]) {
                    scannerLogs[key] = { entries: [] };
                }
                return scannerLogs[key];
            }

            function saveScannerLog() {
                // ... (existing saveScannerLog function) ...
                localStorage.setItem('scannerAI_logs', JSON.stringify(scannerLogs));
            }

            function loadScannerLog() {
                // ... (existing loadScannerLog function) ...
                scannerLogs = JSON.parse(localStorage.getItem('scannerAI_logs')) || {};
            }

            // --- ADDED: Undo Toast Functions ---
            function showUndoToast(message, onUndo) {
                clearTimeout(undoTimeout);
                lastAction = { onUndo }; // Store the undo callback
                ui.undoToastText.textContent = message;
                ui.undoToast.classList.add('opacity-100', '!-translate-x-1/2');
                ui.undoToast.classList.remove('opacity-0', 'translate-y-24'); // translate-y-24 was from a different style

                undoTimeout = setTimeout(hideUndo, 5000); // 5 seconds
            }

            function hideUndo() {
                lastAction = null;
                ui.undoToast.classList.remove('opacity-100', '!-translate-x-1/2');
                ui.undoToast.classList.add('opacity-0');
            }
            // --- END: Undo Toast Functions ---
            
            // --- ADDED: Unified Delete Function ---
            function deleteLogItem(logId, source = 'list') {
                const dayLog = getTodaysLog();
                const logIndex = dayLog.entries.findIndex(entry => entry.logId === logId);

                if (logIndex === -1) return; // Item not found

                const itemToDelete = dayLog.entries.splice(logIndex, 1)[0];
                if (!itemToDelete) return;

                saveScannerLog();
                renderScannerLog(); // Update bottom list

                // Find the carousel card
                const carouselLogButton = ui.scannerResultsContainer.querySelector(`.ai-log-button[data-log-id="${logId}"]`);
                
                if (source === 'carouselDblClick') {
                    // Remove the card from the carousel
                    if (carouselLogButton) {
                        const itemToRemove = carouselLogButton.closest('.scroll-item');
                        if (itemToRemove) {
                            itemToRemove.remove();
                            // After removing, we must recalculate positions for the drag logic
                            // REMOVED: updateCarouselPositions();
                        }
                    }
                } else {
                    // Just update the button to "unlogged" state
                    if (carouselLogButton) {
                        logButtonSetState(carouselLogButton, false, null);
                    }
                }

                // Show undo
                showUndoToast(`Removed "${itemToDelete.name}"`, () => {
                    // Undo logic
                    dayLog.entries.splice(logIndex, 0, itemToDelete); // Re-insert item
                    saveScannerLog();
                    renderScannerLog();
                    
                    // If we removed the card, we can't easily add it back.
                    // So we'll just update the button state *if it still exists*.
                    const buttonToRestore = ui.scannerResultsContainer.querySelector(`.ai-log-button[data-log-id="${logId}"]`);
                    if (buttonToRestore) {
                        logButtonSetState(buttonToRestore, true, logId);
                    }
                    // If the card was removed (carouselDblClick), it stays removed for simplicity.
                    // The item is restored to the log list, which is the main goal.
                });
            }

            // --- ADDED: Helper to set log button state ---
            function logButtonSetState(button, isLogged, logId) {
                if (isLogged) {
                    button.innerHTML = '<i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>';
                    button.title = 'Logged! (Tap to undo)';
                    button.classList.remove('btn-primary');
                    button.classList.add('btn-secondary');
                    button.isLogged = true;
                    button.logId = logId;
                    button.dataset.logId = logId;
                } else {
                    button.innerHTML = '<i data-lucide="check" class="w-4 h-4 pointer-events-none"></i>';
                    button.title = 'Log this';
                    button.classList.remove('btn-secondary');
                    button.classList.add('btn-primary');
                    button.isLogged = false;
                    button.logId = null;
                    button.dataset.logId = "null";
                }
                lucide.createIcons({ root: button });
            }


            function renderScannerLog() {
                // ... (existing renderScannerLog function) ...
                const dayLog = getTodaysLog();
                if (dayLog.entries.length === 0) {
                    ui.scannedLogDisplay.innerHTML = '<p class="text-secondary-text">No items scanned and logged yet.</p>';
                    return;
                }
                ui.scannedLogDisplay.innerHTML = dayLog.entries.map((item, index) => `
                    <div class="bg-card-bg border border-border-color p-3 rounded-lg flex justify-between items-center">
                        <div>
                            <p class="font-medium">${item.servings}x ${item.name} ${item.grams > 0 ? `(${item.grams.toFixed(0)}g)` : ''}</p>
                            <p class="text-sm text-secondary-text">${item.calories?.toFixed(0) || 0}kcal | ${item.protein?.toFixed(1) || 0}p | ${item.carbs?.toFixed(1) || 0}c | ${item.fat?.toFixed(1) || 0}f</p>
                        </div>
                        <button class="btn btn-danger !p-2 remove-log-btn" data-log-id="${item.logId}" title="Remove">
                            <i data-lucide="trash-2" class="w-4 h-4 pointer-events-none"></i>
                        </button>
                    </div>
                `).join('');
                lucide.createIcons();
            } 

            async function getAiImageClassification(imagePart) {
                // ... (existing getAiImageClassification function) ...
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error';
                }
            }

           async function processBarcodeScan(decodedText, file, resultElement) {
                // ... (existing processBarcodeScan function) ...
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (!overlayContent) return;
                overlayContent.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');

                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                    if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                          const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                          if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';
                    
                    if ((productName === 'Scanned Item' && per100g.calories === 0) || !product.product_name) {
                        overlayContent.innerHTML = `<p class="text-yellow-400 text-xs">Could not identify this barcode. Please try a food photo instead.</p>`;
                        return;
                    }
                    
                    const logId = Date.now();
                    const servings = 1;
                    const grams = defaultGrams;
                    const foodItem = {
                        logId: logId, name: productName, brand: product.brands || '',
                        servings: servings, grams: grams,
                        calories: (per100g.calories / 100 * grams) || 0, 
                        protein: (per100g.protein / 100 * grams) || 0, 
                        carbs: (per100g.carbs / 100 * grams) || 0,
                        fat: (per100g.fat / 100 * grams) || 0,
                        sugar: (per100g.sugar / 100 * grams) || 0, 
                        sodium: (per100g.sodium / 100 * grams) || 0, 
                        potassium: (per100g.potassium / 100 * grams) || 0,
                    };
                    const dayLog = getTodaysLog();
                    dayLog.entries.unshift(foodItem);
                    saveScannerLog();
                    renderScannerLog();

                    overlayContent.innerHTML = `
                        <div>
                            <div class="flex justify-between items-start gap-2">
                                <div>
                                    <p class="item-title">${productName} (est. ${defaultGrams.toFixed(0)}g)</p>
                                    <!-- Hiding nutrients in filmstrip -->
                                </div>
                                <button class="btn btn-secondary ai-log-button !p-2 !rounded-full !flex-shrink-0" data-log-id="${logId}" title="Logged! (Tap to undo)">
                                    <i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    lucide.createIcons({ root: overlayContent });
                    
                    const logButton = overlayContent.querySelector('.ai-log-button');
                    logButtonSetState(logButton, true, logId); // Use helper

                    logButton.onclick = () => {
                        const servings = 1;
                        const grams = defaultGrams;

                        if (logButton.isLogged) {
                            // --- MODIFIED: Use deleteLogItem ---
                            deleteLogItem(logButton.logId, 'logButton');
                            logButtonSetState(logButton, false, null); // State is set in deleteLogItem
                        } else {
                            const newLogId = Date.now();
                            const foodItem = {
                                logId: newLogId, name: productName, brand: product.brands || '',
                                servings: servings, grams: grams,
                                calories: (per100g.calories / 100 * grams) || 0, 
                                protein: (per100g.protein / 100 * grams) || 0, 
                                carbs: (per100g.carbs / 100 * grams) || 0,
                                fat: (per100g.fat / 100 * grams) || 0,
                                sugar: (per100g.sugar / 100 * grams) || 0, 
                                sodium: (per100g.sodium / 100 * grams) || 0, 
                                potassium: (per100g.potassium / 100 * grams) || 0,
                            };
                            const dayLog = getTodaysLog();
                            dayLog.entries.unshift(foodItem);
                            saveScannerLog();
                            renderScannerLog();
                            logButtonSetState(logButton, true, newLogId);
                        }
                    };

                } catch (error) {
                    const errorMsg = `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                    overlayContent.innerHTML = errorMsg;
                }
            }

            function autoStopAiCamera() {
                // ... (existing autoStopAiCamera function) ...
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                    foodCameraStream = null;
                    ui.foodScannerStatus.textContent = 'Camera paused.';
                }
            }

            // --- MODIFIED: manualStopAiCamera ---
            function manualStopAiCamera() {
                // --- Capture last frame ---
                const video = ui.foodCameraVideo;
                const overlayCanvas = document.getElementById('camera-overlay-canvas');
                if (overlayCanvas && video.videoWidth > 0 && video.videoHeight > 0) {
                    try {
                        const overlayCtx = overlayCanvas.getContext('2d');
                        overlayCanvas.width = video.videoWidth;
                        overlayCanvas.height = video.videoHeight;
                        overlayCtx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                    } catch (e) {
                        console.error("Error drawing last frame to canvas:", e);
                    }
                }
                // --- End capture ---

                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                    foodCameraStream = null;
                }
                
                // Use opacity for transition
                ui.cameraOverlay.classList.remove('opacity-0', 'pointer-events-none');
                
                ui.foodScannerStatus.textContent = 'Camera off. Tap to start.';
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop().catch(err => console.error("Error stopping barcode scanner:", err));
                }
            }

            async function startAiCamera() {
                // --- MODIFIED: startAiCamera ---
                // Hide overlay
                ui.cameraOverlay.classList.add('opacity-0', 'pointer-events-none');
                ui.liveCameraContainer.classList.remove('hidden');

                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                    foodCameraStream = null;
                }

                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentFacingMode } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                    
                    // MODIFIED: No scroll, camera is fixed
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = `Could not access ${currentFacingMode} camera.`;
                    manualStopAiCamera(); // Show overlay on failure
                }
            }

            // --- ADDED: Flip Camera Function ---
            function flipCamera() {
                currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
                startAiCamera(); // Restart camera with new mode
            }

            function captureAiPhoto() {
                // ... (existing captureAiPhoto function) ...
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    }
                }, 'image/jpeg', 0.9);
            }

            async function processFoodImageAI(imagePart, resultElement) {
                // ... (existing processFoodImageAI function) ...
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (!overlayContent) return;
                overlayContent.innerHTML = '<div class="loader mx-auto"></div>';

                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    const foodName = capitalizeWords(data.name) || 'Unknown Food';

                    if (foodName.toLowerCase().includes('unknown') || foodName.toLowerCase().includes('no food') || foodName.toLowerCase().includes('not food')) {
                        overlayContent.innerHTML = `
                            <div>
                                <p class="item-title text-yellow-400">No food detected</p>
                                <p class="item-nutrients">Please try capturing the image again.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    const logId = Date.now();
                    const servings = data.servings || 1;
                    const grams = data.totalGrams || 0;
                    const foodItem = {
                        logId: logId, name: foodName, brand: data.brand || '',
                        servings: servings, grams: grams,
                        calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                        sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                    };
                    const dayLog = getTodaysLog();
                    dayLog.entries.unshift(foodItem);
                    saveScannerLog();
                    renderScannerLog();
                    
                    overlayContent.innerHTML = `
                        <div>
                            <div class="flex justify-between items-start gap-2">
                                <div>
                                    <p class="item-title">${foodName} (${(data.servings || 1).toFixed(1)} serv.)</p>
                                    <p class="item-nutrients">${data.calories?.toFixed(0) || '?'} kcal | ${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                                </div>
                                <button class="btn btn-secondary ai-log-button !p-2 !rounded-full !flex-shrink-0" data-log-id="${logId}" title="Logged! (Tap to undo)">
                                    <i data-lucide="check-check" class="w-4 h-4 pointer-events-none"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    lucide.createIcons({ root: overlayContent });

                    const logButton = overlayContent.querySelector('.ai-log-button');
                    logButtonSetState(logButton, true, logId); // Use helper

                    logButton.onclick = () => {
                        const servings = data.servings || 1;
                        const grams = data.totalGrams || 0;

                        if (logButton.isLogged) {
                            // --- MODIFIED: Use deleteLogItem ---
                            deleteLogItem(logButton.logId, 'logButton');
                            logButtonSetState(logButton, false, null); // State is set in deleteLogItem
                        } else {
                            const newLogId = Date.Now();
                            const foodItem = {
                                logId: newLogId, name: foodName, brand: data.brand || '',
                                servings: servings, grams: grams,
                                calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                                sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                            };
                            const dayLog = getTodaysLog();
                            dayLog.entries.unshift(foodItem);
                            saveScannerLog();
                            renderScannerLog();
                            logButtonSetState(logButton, true, newLogId);
                        }
                    };

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    const errorMsg = `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                    overlayContent.innerHTML = errorMsg;
                }
            }

            async function classifyAndProcessImage(file, resultElement) {
                // ... (existing classifyAndProcessImage function) ...
                const overlayContent = resultElement.querySelector('.item-overlay-content');
                if (overlayContent) {
                    overlayContent.innerHTML = '<div class="loader mx-auto"></div>';
                }

                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            if (!html5QrCode) {
                                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
                            }
                            const decodedText = await html5QrCode.scanFile(file, false);
                            await processBarcodeScan(decodedText, file, resultElement);
                        } catch (err) {
                             console.warn("Local barcode scan failed, falling back to food AI:", err);
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement);
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement);
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                     console.error("Image Processing Error:", error);
                     const errorMsg = `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                     if (overlayContent) {
                         overlayContent.innerHTML = errorMsg;
                     }
                }
            }

            function handleAiScanFiles(files) {
                // ... (existing handleAiScanFiles function) ...
                if (!files || files.length === 0) return;
                const filesArray = Array.from(files);
                
                // --- ADDED: Double-tap state ---
                let lastTap = 0;

                for(const file of filesArray) {
                    const resultElement = document.createElement('div');
                    // MODIFIED: Smaller filmstrip item styles
                    resultElement.className = 'scroll-item bg-input-bg rounded-lg text-center !flex-shrink-0 h-28 w-28 overflow-hidden relative';

                    resultElement.innerHTML = `
                        <!-- MODIFIED: Added object-cover -->
                        <img class="w-full h-full object-cover" src="https://placehold.co/112x112/191919/191919?text=." alt="Scanned item placeholder">
                        <div class="item-overlay-content">
                        </div>
                    `;
                    
                    // --- ADDED: Double-tap listener ---
                    resultElement.addEventListener('click', (e) => {
                        // Don't interfere with button clicks
                        if (e.target.closest('button')) {
                            return;
                        }

                        const currentTime = new Date().getTime();
                        const timeSinceLastTap = currentTime - lastTap;

                        if (timeSinceLastTap < 300 && timeSinceLastTap > 0) { // Double tap
                            // Find the log button to get the logId
                            const logButton = resultElement.querySelector('.ai-log-button');
                            if (logButton && logButton.logId) {
                                deleteLogItem(logButton.logId, 'carouselDblClick');
                            }
                            lastTap = 0; // Reset tap
                        } else {
                            lastTap = currentTime;
                        }
                    });


                    // MODIFIED: Prepend to the carousel container
                    ui.scannerResultsContainer.prepend(resultElement);

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageUrl = e.target.result;
                        const img = resultElement.querySelector('img');
                        img.src = imageUrl;

                        // --- Show Photo Popup ---
                        if (ui.photoPopup && ui.photoPopupImg) {
                            ui.photoPopupImg.src = imageUrl;
                            ui.photoPopup.style.display = 'block'; // Make it visible for transition
                            setTimeout(() => { // Timeout to allow display:block to register before transition
                                ui.photoPopup.classList.add('show');
                                ui.photoPopup.classList.remove('hide');
                            }, 10);

                            setTimeout(() => {
                                ui.photoPopup.classList.add('hide');
                                ui.photoPopup.classList.remove('show');
                                setTimeout(() => {
                                    if (!ui.photoPopup.classList.contains('show')) {
                                        ui.photoPopup.style.display = 'none';
                                    }
                                }, 300);
                            }, 2000); // Show for 2 seconds
                        }
                        // --- End Photo Popup ---
                        
                        classifyAndProcessImage(file, resultElement);
                    };
                     reader.onerror = () => {
                         const overlayContent = resultElement.querySelector('.item-overlay-content');
                         if (overlayContent) {
                             overlayContent.innerHTML = `<p class="text-red-400 text-xs">Error reading file.</p>`;
                         }
                     };
                     reader.readAsDataURL(file);

                    // MODIFIED: Scroll to the camera, not the new element
                    setTimeout(() => {
                        // Scroll to the new item first, then snap back
                        resultElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }, 100); 
                }
                 // REMOVED call to setupCarousel
            }
            
            function getPointerCoordinates(e) {
                return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
            }

            // --- REMOVED: Carousel Drag Logic ---
            // Native scroll is now used for the filmstrip
            
            // --- MODIFIED: Listeners ---
            ui.scannerResultsContainer.addEventListener('mousedown', (e) => {
                // Simple grab cursor logic
                ui.scannerResultsContainer.style.cursor = 'grabbing';
            });
            ui.scannerResultsContainer.addEventListener('mouseup', () => {
                ui.scannerResultsContainer.style.cursor = 'grab';
            });
            ui.scannerResultsContainer.addEventListener('mouseleave', () => {
                ui.scannerResultsContainer.style.cursor = 'grab';
            });


            ui.startCameraOverlayBtn.addEventListener('click', startAiCamera); // Listener for new button
            ui.stopFoodCameraBtn.addEventListener('click', manualStopAiCamera);
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);
            ui.uploadPhotoInput.addEventListener('change', (e) => handleAiScanFiles(e.target.files));

            ui.scannedLogDisplay.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-log-btn');
                if (removeBtn) {
                    const logId = parseInt(removeBtn.dataset.logId);
                    if (isNaN(logId)) return;
                    // --- MODIFIED: Use deleteLogItem ---
                    deleteLogItem(logId, 'list');
                }
            });

            // MODIFIED: logAllBtn -> flipCameraBtn
            ui.flipCameraBtn.addEventListener('click', flipCamera); 

            // --- ADDED: Undo Button Listener ---
            ui.undoToastBtn.addEventListener('click', () => {
                if (lastAction && typeof lastAction.onUndo === 'function') {
                    lastAction.onUndo();
                }
                hideUndo();
            });
            
            // --- ADDED: Scanned Log Modal Listeners ---
            ui.scannedLogPopupBtn.addEventListener('click', () => {
                renderScannerLog(); // Ensure list is up-to-date
                showModal(ui.scannedLogModal);
            });
            ui.closeScannedLogModalBtn.addEventListener('click', () => hideModal(ui.scannedLogModal));
            ui.scannedLogModalOkBtn.addEventListener('click', () => hideModal(ui.scannedLogModal));


            // REMOVED: Camera Observer
                
            loadScannerLog();
            renderScannerLog();
            
            // Initial setup
            // REMOVED: updateCarouselPositions(); 
            startAiCamera(); // Start camera on load
        }

        // Initialize layout and page logic on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeLayout);
    </script>
</body>
</html>
