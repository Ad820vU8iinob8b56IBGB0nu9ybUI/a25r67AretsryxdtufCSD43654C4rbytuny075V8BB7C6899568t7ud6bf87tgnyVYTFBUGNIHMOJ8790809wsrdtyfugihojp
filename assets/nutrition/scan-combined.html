<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kowbi | AI Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <!-- Link to shared styles -->
    <link rel="stylesheet" href="../styles.css">
    <style>
        /*
          Most base styles (theme, inputs, buttons) are now
          loaded from ../styles.css
          We only keep styles *specific* to this page.
        */

        /* Carousel Styles */
        .carousel-wrapper {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }
        .carousel-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background-color: rgba(17, 17, 17, 0.7);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            width: 2.5rem;
            height: 2.5rem;
            display: flex; /* Always display for proper alignment, hide via JS */
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .carousel-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .carousel-btn:hover {
            background-color: var(--input-bg);
        }
        .carousel-prev { left: -0.75rem; }
        .carousel-next { right: -0.75rem; }

        .horizontal-scroll-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            gap: 1rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            /* Hide scrollbars */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex: 0 0 85%; /* Default item width */
            width: 85%;
            scroll-snap-align: center;
            white-space: normal;
        }
        /* Centering padding */
        .horizontal-scroll-container::before,
        .horizontal-scroll-container::after {
            content: '';
            width: calc((100% - 85%) / 2 - 0.5rem);
            flex-shrink: 0;
        }

        /* Wider items for scanner carousels */
        .scanner-carousel .scroll-item {
            flex: 0 0 95%; /* Make scanner items wider */
            width: 95%;
            scroll-snap-align: start; /* Align to start for better visibility */
        }
        .scanner-carousel::before,
        .scanner-carousel::after {
            width: calc((100% - 95%) / 2 - 0.5rem);
        }
        .hidden { display: none; }
    </style>
</head>
<body class="antialiased">

     <script>
        // Apply theme immediately
        (function() {
            const theme = localStorage.getItem('fitTrackAI_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
    
    <div class="container mx-auto max-w-7xl px-4 py-6">
        <!-- Header Placeholder -->
        <div id="header-placeholder"></div>

        <!-- Main Content Area -->
        <main class="max-w-xl mx-auto">
            <!-- AI Scanner Card (was modal-content) -->
            <div id="ai-scanner-card" class="content-card">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold">AI Scanner</h2>
                    <a href="../../nutrition.html" id="close-ai-scanner-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</a>
                </div>
                <div class="space-y-4">
                    <div id="ai-scanner-initial-options" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <label for="ai-upload-photo-input" class="btn btn-secondary cursor-pointer"><i data-lucide="upload"></i>Upload</label>
                        <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                        <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Live Camera</button>
                    </div>
                    <div id="ai-live-camera-container" class="hidden space-y-2">
                        <video id="ai-camera-video" class="w-full rounded-lg border border-border-color" autoplay playsinline></video>
                        <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames -->
                        <button id="capture-ai-photo-btn" class="btn btn-primary w-full">Capture Photo</button>
                        <button id="stop-ai-camera-btn" class="btn btn-danger w-full">Close Camera</button>
                    </div>
                    <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
                    <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper hidden">
                        <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                        <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 min-h-[220px] !flex !flex-row !flex-nowrap">
                            <!-- Results injected here -->
                        </div>
                        <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>

    <!-- Standalone alert modal for errors -->
    <div id="alert-modal" class="modal-backdrop" style="z-index: 80; display: none;">
        <div class="modal-content">
            <h2 id="alert-modal-title" class="text-2xl font-bold mb-4">Alert</h2>
            <p id="alert-modal-text" class="text-gray-300 mb-6"></p>
            <button id="alert-modal-ok-btn" class="btn btn-primary w-full">OK</button>
        </div>
    </div>
    
    <!-- Footer Placeholder -->
    <div id="footer-placeholder"></div>


    <script>
        // --- Load Header and Footer ---
        async function loadComponent(url, placeholderId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}: ${response.statusText}`);
                let text = await response.text();
                
                // Adjust relative paths in loaded HTML
                text = text.replace(/href="index\.html"/g, 'href="../../index.html"');
                text = text.replace(/href="settings\.html"/g, 'href="../../settings.html"');
                text = text.replace(/href="nutrition\.html"/g, 'href="../../nutrition.html"');
                text = text.replace(/href="workouts\.html"/g, 'href="../../workouts.html"');
                text = text.replace(/href="sleep\.html"/g, 'href="../../sleep.html"');
                text = text.replace(/href="progress\.html"/g, 'href="../../progress.html"');
                text = text.replace(/href="social\.html"/g, 'href="../../social.html"');

                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = text;
                }
            } catch (error) {
                console.error(`Error loading component from ${url}:`, error);
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = `<p class="text-red-500 text-center">Error loading component.</p>`;
                }
            }
        }

        async function initializeLayout() {
            await Promise.all([
                loadComponent('../header.html', 'header-placeholder'), // Path is ../ from assets/nutrition/
                loadComponent('../footer.html', 'footer-placeholder') // Path is ../ from assets/nutrition/
            ]);
            lucide.createIcons(); // Re-render icons after loading components

            // --- Set Active Footer Link ---
            const currentPage = 'nutrition'; // This page is part of nutrition
            const navLinks = document.querySelectorAll('#mobile-footer-nav .nav-link');
            navLinks.forEach(link => {
                const linkPage = link.getAttribute('data-page');
                if (linkPage === currentPage) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });

            // --- Initialize Page Specific JS ---
            initializeAppPage();
        }
        // --- End Load Header and Footer ---
        
        // --- Original page script wrapped in a function ---
        function initializeAppPage() {
            // --- STATE MANAGEMENT (Simulated - for standalone functionality) ---
            let allDailyLogs = {}; // Keep logs locally for this instance
            let viewDate = new Date(); viewDate.setHours(0,0,0,0);
            let foodCameraStream = null;
            let activeRecipeScanBtn = null; // Will be null in standalone context
            let html5QrCode = null; // Store the scanner instance
            let openModalCount = 0; // Only for alert modal

            // --- CORE & HELPER FUNCTIONS (Copied from nutrition.html) ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function getDayLog(date) {
                const key = dateToKey(date);
                if (!allDailyLogs[key]) {
                    allDailyLogs[key] = { entries: [], water: 0 };
                }
                if (typeof allDailyLogs[key].water === 'undefined') {
                     allDailyLogs[key].water = 0;
                }
                return allDailyLogs[key];
            }

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                 const apiKey = "AIzaSyDY48xF1byvU05kS9qKvN8iyrIR3hheP8w"; // Leave empty for Canvas environment
                 return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                           // Check for expected data in the response structure
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                                // Continue retrying if format is wrong, unless last attempt
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry on rate limit or server errors
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; // Exponential backoff with jitter
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            throw new Error(`API Error: ${response.status} - ${await response.text()}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // --- Modal show/hide functions (Simplified for standalone) ---
            function showModal(modalElement) {
                modalElement.style.display = 'flex';
                openModalCount++;
            }
            function hideModal(modalElement) {
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                     openModalCount = 0; // Failsafe
                }
            }

            // Simple alert function using the alert modal
            function showCustomAlert(title, text) {
                const alertModal = document.getElementById('alert-modal');
                if (alertModal.style.display === 'flex') return;
                document.getElementById('alert-modal-title').textContent = title;
                document.getElementById('alert-modal-text').textContent = text;
                showModal(alertModal);
            }

            // --- UI ELEMENT DEFINITIONS (Scoped to this file) ---
            const ui = {
                foodScannerModal: document.getElementById('ai-scanner-card'), // Changed to card
                closeFoodScannerModalBtn: document.getElementById('close-ai-scanner-modal-btn'),
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),
                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),
                alertModal: document.getElementById('alert-modal'), // Added alert modal elements
                alertModalTitle: document.getElementById('alert-modal-title'),
                alertModalText: document.getElementById('alert-modal-text'),
                alertModalOkBtn: document.getElementById('alert-modal-ok-btn')
            };

            // --- SCANNER FUNCTIONS (Copied & adapted) ---

            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     console.warn(`Carousel setup failed for ${containerId}. Missing elements.`);
                     return;
                }

                const updateCarouselButtons = () => {
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;
                    prevBtn.classList.toggle('visible', scrollLeft > 10);
                    // Only show next button if there is scrollable content beyond the current view
                    nextBtn.classList.toggle('visible', scrollLeft < scrollWidth - clientWidth - 10);
                };

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    // Calculate scroll based on one item width + gap (1rem = 16px)
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => { container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' }); };
                nextBtn.onclick = () => { container.scrollBy({ left: scrollAmount(), behavior: 'smooth' }); };
                container.addEventListener('scroll', updateCarouselButtons);
                // Initial check after content might have been added
                setTimeout(updateCarouselButtons, 100); 
                // Force scroll to the newly added item (right-most)
                container.scrollLeft = container.scrollWidth;
            }
            
            // NEW FUNCTION: Reset the scanner UI state
            function resetScannerUI() {
                ui.scannerResultsContainer.innerHTML = '';
                ui.foodScannerCarouselWrapper.classList.add('hidden');
                ui.foodScannerStatus.textContent = '';
                // Ensure camera is stopped if it was running
                stopAiCamera();
                // Reset the file input value so 'change' event fires even if the same file is selected again
                ui.uploadPhotoInput.value = '';
            }

            function fileToGenerativePart(file) {
                 return new Promise((resolve, reject) => {
                     const reader = new FileReader();
                     reader.onloadend = () => {
                         const base64Data = reader.result.split(',')[1];
                         resolve({ inlineData: { mimeType: file.type, data: base64Data } });
                     };
                     reader.onerror = (err) => reject(err);
                     reader.readAsDataURL(file);
                 });
            }

            async function getAiImageClassification(imagePart) {
                const prompt = "Is this image primarily a barcode or a picture of food? Respond with ONLY 'barcode' or 'food'.";
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid classification response.");
                    return result.candidates[0].content.parts[0].text.trim().toLowerCase();
                } catch (error) {
                    console.error("AI Classification Error:", error);
                    return 'error';
                }
            }

           async function processBarcodeScan(decodedText, file, resultElement) {
                const imageUrl = URL.createObjectURL(file);
                resultElement.querySelector('img').src = imageUrl;
                resultElement.querySelector('img').onerror = function() { this.onerror=null; this.src='https://placehold.co/300x150/191919/FFFFFF?text=No+Image'; };
                resultElement.querySelector('.loader')?.classList.remove('hidden');

                try {
                    // Using Open Food Facts API
                    const response = await fetch(`https://world.openfoodfacts.org/api/v2/product/${decodedText}?fields=product_name,brands,nutriments,serving_size,quantity`);
                    if(!response.ok) throw new Error('Product not found in Open Food Facts database.');
                    const data = await response.json();
                    if(data.status === 0 || !data.product) throw new Error(data.status_verbose || 'Product not found.');

                    const product = data.product, nutriments = product.nutriments;
                    const per100g = {
                        calories: nutriments['energy-kcal_100g'] || 0, protein: nutriments.proteins_100g || 0, carbs: nutriments.carbohydrates_100g || 0, fat: nutriments.fat_100g || 0, sugar: nutriments.sugars_100g || 0, sodium: (nutriments.sodium_100g || 0) * 1000, potassium: (nutriments.potassium_100g || 0) * 1000,
                    };

                    let defaultGrams = 100;
                     if (product.serving_size) {
                        const servingMatch = String(product.serving_size).match(/(\d+(\.\d+)?)/);
                        if (servingMatch) { defaultGrams = parseFloat(servingMatch[0]); }
                    } else if (product.quantity) {
                         const quantityMatch = String(product.quantity).match(/(\d+(\.\d+)?)/);
                         if (quantityMatch) { defaultGrams = parseFloat(quantityMatch[0]); }
                    }

                    const productName = capitalizeWords(product.product_name) || 'Scanned Item';

                    const detailsContainer = document.createElement('div');
                    detailsContainer.innerHTML = `
                        <p class="font-bold whitespace-normal">${productName}</p>
                        <p class="text-xs text-gray-400 mb-3">Barcode: ${decodedText}</p>
                        <div class="flex items-center gap-2">
                            <input type="number" value="${defaultGrams.toFixed(0)}" class="form-input !py-1.5 text-center barcode-grams-input" min="0">
                            <span class="text-gray-400">grams</span>
                        </div>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full data-log-button';
                    logButton.textContent = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    const gramsInput = detailsContainer.querySelector('.barcode-grams-input');

                    logButton.onclick = () => {
                        const grams = parseFloat(gramsInput.value);
                        if (isNaN(grams) || grams <= 0) {
                            gramsInput.classList.add('!border-red-500');
                            setTimeout(() => gramsInput.classList.remove('!border-red-500'), 1500);
                            return;
                        }
                        
                        // We can't log to the main app, so we'll store it in a
                        // temporary localstorage key that nutrition.html can read
                        const logId = Date.now();
                        const ratio = grams / 100.0;
                        const foodItem = {
                            logId: logId, name: productName, brand: product.brands || '', servings: 1, grams: grams,
                            calories: (per100g.calories * ratio) || 0, protein: (per100g.protein * ratio) || 0,
                            carbs: (per100g.carbs * ratio) || 0, fat: (per100g.fat * ratio) || 0,
                            sugar: (per100g.sugar * ratio) || 0, sodium: (per100g.sodium * ratio) || 0,
                            potassium: (per100g.potassium * ratio) || 0,
                        };
                        
                        // Use a temporary key to pass data back
                        localStorage.setItem('fitTrackAI_tempScannedItem', JSON.stringify(foodItem));
                        
                        // Show feedback and redirect
                        logButton.textContent = 'Logged! Redirecting...';
                        logButton.disabled = true;
                        gramsInput.disabled = true;
                        
                        setTimeout(() => {
                            window.location.href = '../../nutrition.html';
                        }, 1000);
                    };

                    resultElement.querySelector('.loader')?.remove();
                    resultElement.appendChild(detailsContainer);
                    resultElement.appendChild(logButton);
                    lucide.createIcons(); // Render icons if any are added

                } catch (error) {
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Error finding barcode data. ${error.message}</p>`;
                }
            }


            async function startAiCamera() {
                ui.foodScannerInitialOptions.classList.add('hidden');
                ui.liveCameraContainer.classList.remove('hidden');
                ui.foodScannerStatus.textContent = 'Starting camera...';
                try {
                    foodCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    ui.foodCameraVideo.srcObject = foodCameraStream;
                    ui.foodScannerStatus.textContent = 'Camera active. Point and capture.';
                } catch (err) {
                    console.error("Camera access error:", err);
                    ui.foodScannerStatus.textContent = 'Could not access camera.';
                    stopAiCamera(); // Stop camera if failed
                }
            }

            function stopAiCamera() {
                if (foodCameraStream) {
                    foodCameraStream.getTracks().forEach(track => track.stop());
                }
                foodCameraStream = null;
                ui.liveCameraContainer.classList.add('hidden');
                ui.foodScannerInitialOptions.classList.remove('hidden');
                // The status text is handled by resetScannerUI if it was called before starting the camera
                // or after processing/closing the modal.
                // ui.foodScannerStatus.textContent = ''; // Removed: Handled by resetScannerUI
                // Ensure html5QrCode scanner is stopped if it was running
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop().catch(err => console.error("Error stopping barcode scanner:", err));
                }
            }

            function captureAiPhoto() {
                const video = ui.foodCameraVideo;
                const canvas = ui.foodCameraCanvas;
                if (!video.videoWidth || !video.videoHeight) {
                    showCustomAlert("Error", "Camera stream not ready. Please try again.");
                    return;
                }
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const context = canvas.getContext('2d');
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob(blob => {
                    if (blob) {
                        const file = new File([blob], `capture-${Date.now()}.jpg`, { type: 'image/jpeg' });
                        handleAiScanFiles([file]);
                    } else {
                        showCustomAlert("Error", "Could not capture image from camera.");
                    }
                }, 'image/jpeg', 0.9);
            }

            async function processFoodImageAI(imagePart, resultElement) {
                resultElement.querySelector('.loader')?.classList.remove('hidden'); // Show loader
                try {
                    let prompt = `Identify the food in this image. Respond ONLY with a valid JSON object with these fields: "name", "brand", "servings" (estimated number of standard servings shown), "totalGrams" (estimated total grams for all servings shown), "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". The nutritional values (calories, protein, etc.) should be for the TOTAL amount of food pictured.`;

                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = { contents: [{ parts: [{ text: prompt }, imagePart] }], generationConfig: { responseMimeType: "application/json" } };

                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");

                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    resultElement.querySelector('.loader')?.remove();

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'text-xs text-gray-400 whitespace-normal';

                    detailsDiv.innerHTML = `
                        <p class="font-bold text-sm text-white mb-1">${capitalizeWords(data.name) || 'Unknown Food'} (${(data.servings || 1).toFixed(1)} serv.)</p>
                        <p>${data.totalGrams?.toFixed(0) || '?'}g | ${data.calories?.toFixed(0) || '?'} kcal</p>
                        <p>${data.protein?.toFixed(1) || '?'}p | ${data.carbs?.toFixed(1) || '?'}c | ${data.fat?.toFixed(1) || '?'}f</p>
                    `;

                    const logButton = document.createElement('button');
                    logButton.className = 'btn btn-primary !p-2 mt-3 w-full';
                    logButton.innerHTML = 'Log this';
                    logButton.isLogged = false;
                    logButton.logId = null;

                    logButton.onclick = () => {
                         const servings = data.servings || 1;
                         const grams = data.totalGrams || 0;
                         const perServingGrams = servings > 0 ? grams / servings : 0;
                         
                        const logId = Date.now();
                        const foodItem = {
                            logId: logId, name: capitalizeWords(data.name) || 'Scanned Food', brand: data.brand || '',
                            servings: servings, grams: grams,
                            calories: data.calories || 0, protein: data.protein || 0, carbs: data.carbs || 0, fat: data.fat || 0,
                            sugar: data.sugar || 0, sodium: data.sodium || 0, potassium: data.potassium || 0,
                        };

                        // Use a temporary key to pass data back
                        localStorage.setItem('fitTrackAI_tempScannedItem', JSON.stringify(foodItem));
                        
                        // Show feedback and redirect
                        logButton.textContent = 'Logged! Redirecting...';
                        logButton.disabled = true;
                        
                        setTimeout(() => {
                            window.location.href = '../../nutrition.html';
                        }, 1000);
                    };
                    resultElement.appendChild(detailsDiv);
                    resultElement.appendChild(logButton);
                    lucide.createIcons(); // Render icons if any added

                } catch (error) {
                    console.error("AI Image Scan Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                     resultElement.innerHTML += `<p class="text-red-400 text-xs">Error analyzing. ${error.message}</p>`;
                }
            }

            async function classifyAndProcessImage(file, resultElement) {
                try {
                    const imagePart = await fileToGenerativePart(file);
                    const classification = await getAiImageClassification(imagePart);

                    if (classification.includes('barcode')) {
                        ui.foodScannerStatus.textContent = 'Barcode detected, scanning...';
                        try {
                            if (!html5QrCode) {
                                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
                            }
                            // Attempt local scan first
                            const decodedText = await html5QrCode.scanFile(file, false);
                            await processBarcodeScan(decodedText, file, resultElement);
                        } catch (err) {
                             console.warn("Local barcode scan failed, falling back to food AI:", err);
                             // If local barcode fails, try classifying as food instead
                            ui.foodScannerStatus.textContent = 'Barcode scan failed, trying food analysis...';
                            await processFoodImageAI(imagePart, resultElement);
                        }
                    } else if (classification.includes('food')) {
                        ui.foodScannerStatus.textContent = 'Food detected, analyzing...';
                        await processFoodImageAI(imagePart, resultElement);
                    } else {
                        throw new Error("Could not classify image.");
                    }
                } catch (error) {
                     console.error("Image Processing Error:", error);
                    resultElement.querySelector('.loader')?.remove();
                    resultElement.innerHTML += `<p class="text-red-400 text-xs">Scan failed. ${error.message}</p>`;
                } finally {
                     resultElement.querySelector('.loader')?.remove(); // Ensure loader removed on error too
                }
            }


            function handleAiScanFiles(files) {
                if (!files || files.length === 0) return;
                ui.foodScannerCarouselWrapper.classList.remove('hidden');

                const filesArray = Array.from(files);

                for(const file of filesArray) {
                    const resultElement = document.createElement('div');
                    resultElement.className = 'scroll-item p-4 bg-input-bg rounded-lg text-center !flex-shrink-0'; // Ensure shrink-0

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        resultElement.innerHTML = `
                            <img src="${e.target.result}" class="w-full h-24 object-cover rounded-md mb-2">
                            <div class="loader mx-auto hidden"></div>
                        `;
                        classifyAndProcessImage(file, resultElement); // Process after setting initial HTML
                    };
                     reader.onerror = () => {
                        resultElement.innerHTML = `<p class="text-red-400 text-xs">Error reading file.</p>`;
                    };
                    reader.readAsDataURL(file);
                    ui.scannerResultsContainer.appendChild(resultElement);
                }
                 // Re-setup carousel after adding items
                 setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
            }


            // --- EVENT LISTENERS (Scoped) ---
            ui.closeFoodScannerModalBtn.addEventListener('click', () => {
                resetScannerUI(); // Use the unified reset function
                // window.location.href = '../../nutrition.html'; // Already an <a> tag
                stopAiCamera(); // Make sure camera stops on click
            });

            // Use the unified reset function before starting the camera
            ui.startFoodCameraBtn.addEventListener('click', () => {
                resetScannerUI(); 
                // Now start the camera
                startAiCamera();
            });

            ui.stopFoodCameraBtn.addEventListener('click', stopAiCamera);
            
            ui.captureFoodPhotoBtn.addEventListener('click', captureAiPhoto);

            // Use the unified reset function before processing uploads
            ui.uploadPhotoInput.addEventListener('change', (e) => {
                resetScannerUI(); 
                handleAiScanFiles(e.target.files);
            });

            // Alert modal OK button
             ui.alertModalOkBtn.addEventListener('click', () => hideModal(ui.alertModal));

            // --- INITIALIZATION ---
            // lucide.createIcons(); // Moved to initializeLayout
            // Initialize html5QrCode scanner instance
            if (!html5QrCode) {
                html5QrCode = new Html5Qrcode("barcode-reader-hidden-helper");
            }
            // Setup the carousel immediately (will be called again after content is added)
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');
        }

        // Initialize layout and page logic on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeLayout);
    </script>
</body>
</html>