<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-AR">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kowbi | nutrition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Added for barcode scanning -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    
    <!-- 
      FIX 1: Removed the large <style> block that was here.
      FIX 2: Added the link to the shared stylesheet.
    -->
    <link rel="stylesheet" href="assets/styles.css">
    
    <!-- Page-specific styles (if any are needed, they can go here) -->
    <style>
        /* This block is now much smaller and only contains styles
           that might be *truly* unique to nutrition.html, 
           though most are already in assets/styles.css
        */
        
        /* --- Compound Food Modal Styles (scoped) --- */
        @media (min-width: 768px) {
            #compound-food-modal .modal-content {
                width: 90vw;
                max-width: 48rem;
                padding: 2rem;
            }
        }
        #recipe-name-input::placeholder {
            color: var(--accent);
            font-weight: 700;
            opacity: 0.8;
        }
        .section-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .disabled-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none; /* Hide by default */
            align-items: center;
            justify-content: center;
            background-color: rgba(17, 17, 17, 0.8); /* --card-bg with opacity */
            z-index: 5;
            border-radius: 0.5rem;
            text-align: center;
            padding: 1rem;
            color: var(--primary-text);
            font-weight: 500;
        }
        .section-disabled + .disabled-overlay {
            display: flex;
        }

        /* Scoped scrollbar styles for recipe modal */
        #compound-food-modal .custom-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #compound-food-modal .custom-scrollbar::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Scoped carousel styles for recipe modal */
        #compound-food-modal .scroll-item {
            flex: 0 0 100%; /* Make items fill width */
            width: 100%;
        }
        #compound-food-modal .horizontal-scroll-container::before,
        #compound-food-modal .horizontal-scroll-container::after {
            content: none; /* Remove side padding */
        }

        .ingredient-row {
            width: 100%;
            white-space: normal;
        }
        .ingredient-number {
            width: 1.5rem;
            height: 1.5rem;
            background-color: var(--accent);
            color: var(--background);
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 700;
            flex-shrink: 0; /* Prevent number from shrinking */
        }
        /* --- END: Compound Food Modal Styles --- */

        /* FIX 2: Layout for Desktop (md:) */
        @media (min-width: 768px) {
            #main-centered-content {
                max-width: 650px; /* Max width for readability */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body class="antialiased">

     <script>
        // Apply theme immediately
        (function() {
            const theme = localStorage.getItem('fitTrackAI_theme') || 'dark';
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>

    <div class="container mx-auto max-w-7xl px-4 py-6">
        
        <!-- FIX 3: Added Header Placeholder -->
        <div id="header-placeholder"></div>

        <!-- Main Content -->
        <main id="main-centered-content" class="space-y-4 max-w-xl mx-auto">
             <!-- Combined Container for all cards. order-1 and order-2 classes are now removed from parent divs as they are unnecessary -->

            <!-- Daily Summary Card (Order 1) -->
            <div id="daily-summary-card" class="content-card order-1">
                <!-- Date Navigation & Chart -->
                <div class="flex items-center justify-between mb-4">
                    <div class="text-left">
                        <h3 class="text-xl">
                            <span id="day-view-title-span" class="block text-2xl font-bold cursor-pointer">Today</span>
                            <span id="day-view-date-span" class="text-base  text-secondary-text cursor-pointer"></span>
                        </h3>
                    </div>
                    <div class="w-16 h-16">
                        <canvas id="macro-chart"></canvas>
                    </div>
                </div>
                <div class="w-full grid grid-cols-2 gap-x-6 gap-y-2 text-xs sm:text-sm">
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Calories:</span> <span class="font-semibold"><span id="current-calories">0</span> / <span id="goal-calories">2000</span></span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Protein:</span> <span class="font-semibold"><span id="current-protein">0</span> / <span id="goal-protein">150</span> g</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Carbs:</span> <span class="font-semibold"><span id="current-carbs">0</span> / <span id="goal-carbs">225</span> g</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Fat:</span> <span class="font-semibold"><span id="current-fat">0</span> / <span id="goal-fat">60</span> g</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Na:</span> <span class="font-semibold"><span id="current-sodium">0</span> / <span id="goal-sodium">2300</span> mg</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">K:</span> <span class="font-semibold"><span id="current-potassium">0</span> / <span id="goal-potassium">3500</span> mg</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Sugar:</span> <span class="font-semibold"><span id="current-sugar">0</span> / <span id="goal-sugar">50</span> g</span></div>
                    <div class="flex justify-between items-baseline"><span class="text-gray-400">Water:</span> <span class="font-semibold"><span id="current-water">0</span> / <span id="goal-water">2500</span> ml</span></div>
                </div>
            </div>

            <!-- Log Your Meal Card (Order 2) -->
            <div id="log-meal-card" class="content-card order-2">
                <h3 class="text-2xl font-bold mb-6">Log Your Meal</h3>
                <form id="log-meal-form" class="space-y-4">
                    <div>
                        <label for="food-name-input" class="form-label">Food Name *</label>
                        <input type="text" id="food-name-input" list="favorite-foods-datalist" placeholder="e.g., Chicken Breast" class="form-input mt-1">
                        <datalist id="favorite-foods-datalist"></datalist>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="food-servings-input" class="form-label">Servings *</label>
                            <input type="number" id="food-servings-input" placeholder="1" value="1" min="0" step="0.1" class="form-input mt-1">
                        </div>
                        <div>
                            <label for="food-brand-input" class="form-label">Brand (Optional)</label>
                            <input type="text" id="food-brand-input" placeholder="e.g., Tesco" class="form-input mt-1">
                        </div>
                    </div>
                    <details class="pt-2">
                        <summary class="cursor-pointer text-sm text-gray-400 hover:text-white flex items-center justify-between">
                            <span>Enter Macros for 1 Serving</span>
                            <i data-lucide="chevron-down" class="w-4 h-4 chevron"></i>
                        </summary>
                        <div class="space-y-3 pt-2 mt-2 border-t border-gray-800">
                            <div class="grid grid-cols-4 gap-2">
                                <div>
                                    <label class="form-label text-xs">Calories</label>
                                    <input type="number" step="0.01" id="food-calories-input" min="0" placeholder="kcal" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label class="form-label text-xs">Protein</label>
                                    <input type="number" step="0.01" id="food-protein-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label class="form-label text-xs">Fat</label>
                                    <input type="number" step="0.01" id="food-fat-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label class="form-label text-xs">Carbs</label>
                                    <input type="number" step="0.01" id="food-carbs-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                            </div>
                            <div class="grid grid-cols-4 gap-2">
                                <div>
                                    <label class="form-label text-xs">Sugar</label>
                                    <input type="number" step="0.01" id="food-sugar-input" min="0" placeholder="g" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label class="form-label text-xs">Potassium</label>
                                    <input type="number" step="0.01" id="food-potassium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label class="form-label text-xs">Sodium</label>
                                    <input type="number" step="0.01" id="food-sodium-input" min="0" placeholder="mg" class="form-input mt-1 !py-1.5 text-sm macro-input">
                                </div>
                                <div>
                                    <label for="food-grams-input" class="form-label text-xs">Grams</label>
                                    <input type="number" id="food-grams-input" placeholder="g" min="0" class="form-input mt-1 !py-1.5 text-sm">
                                </div>
                            </div>
                        </div>
                    </details>
                    <!-- Updated Button Grid -->
                    <div class="grid grid-cols-5 gap-2 sm:gap-4"> <!-- MODIFIED: to 5 cols -->
                        <!-- Compound Food/Recipe Button (Changed to <a>) -->
                        <a id="open-compound-food-modal-btn" href="assets/nutrition/open-compound-food-modal.html" class="btn btn-secondary !p-2 sm:!p-3" title="Build a Recipe">
                            <i data-lucide="chef-hat" class="w-4 h-4 sm:w-5 sm:h-5"></i>
                        </a>
                        <!-- AI Macro Swap Button (Remains a <button>) -->
                        <button id="ai-macro-swap-btn" type="button" class="btn btn-secondary !p-2 sm:!p-3" title="AI Macro Swap">
                            <i data-lucide="replace" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                            <div class="loader hidden"></div>
                        </button>
                        <!-- Add Food (AI Lookup) Button -->
                        <button id="add-food-btn" type="button" class="btn btn-primary !p-2 sm:!p-3" title="Add Food / AI Lookup">
                            <i data-lucide="sparkles" class="w-4 h-4 sm:w-5 sm:h-5 btn-text"></i>
                            <div class="loader hidden"></div>
                        </button>
                        <!-- Combined Scan Button (Changed to <a>) -->
                        <a id="scan-combined-btn" href="assets/nutrition/scan-combined.html" class="btn btn-secondary !p-2 sm:!p-3" title="Scan Barcode or Food"><i data-lucide="scan-line" class="w-4 h-4 sm:w-5 sm:h-5"></i></a>
                        <!-- Log Water Button -->
                        <button id="add-water-btn" type="button" class="btn btn-secondary !p-0 !p-0 sm:!p-0 !relative !overflow-hidden" title="Log Water (Tap, Swipe Up/Down, Swipe Left/Right)">
                            <!-- Swipe backgrounds -->
                            <div id="water-swipe-actions" class="swipe-actions">
                                <!-- NEW: Purple swipe down background -->
                                <!-- 
                                    CHANGE 1: Changed !items-start to !items-center to vertically center the icon
                                    in the purple area as it's swiped down.
                                -->
                                <div id="water-swipe-bg-top" class="swipe-action-container !items-center !justify-center" style="opacity: 0; background: linear-gradient(to bottom, hsl(262, 83%, 60%), hsl(262, 83%, 70%)); height: 0; transition: height 0.3s ease; top: 0; left: 0; right: 0; bottom: auto;">
                                    <div class="action !h-auto py-3 !justify-center"><i data-lucide="target" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                </div>
                                <!-- MODIFIED: Green swipe left background -->
                                <!-- USER EDIT: Centered justify-start to justify-center -->
                                <div id="water-swipe-bg-left" class="swipe-action-container left !justify-center" style="opacity: 0; background: linear-gradient(to right, hsl(145, 63%, 49%), hsl(145, 63%, 59%));">
                                    <div class="action"><i data-lucide="edit-3" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                </div>
                                <!-- USER EDIT: Centered justify-end to justify-center -->
                                <div id="water-swipe-bg-right" class="swipe-action-container right !justify-center" style="opacity: 0; background: linear-gradient(to left, hsl(0, 82%, 61%), hsl(0, 72%, 51%));">
                                    <div class="action"><i data-lucide="minus" class="w-4 h-4 sm:w-5 sm:h-5 pointer-events-none"></i></div>
                                </div>
                            </div>

                            <!-- This is the part that moves -->
                            <div id="water-swipe-content" class="swipe-content relative w-full h-full flex items-center justify-center !p-2 sm:!p-3 !bg-transparent transition-colors duration-200">
                                <span id="water-fill"></span> <!-- Fill element -->
                                <i data-lucide="glass-water" class="w-4 h-4 sm:w-5 sm:h-5 relative z-10"></i> <!-- Icon on top -->
                            </div>
                        </button>
                    </div>
                    <div id="add-food-error" class="text-red-400 text-sm mt-2"></div>
                </form>
            </div>

            <!-- Daily Log Content & AI Report Output (Order 3) -->
            <div class="content-card order-3">
                 <div class="flex justify-between items-center mb-4">
                     <h3 class="text-2xl font-bold">Daily Log</h3>
                     <div class="flex items-center gap-2">
                         <!-- AI Daily Report Button (Remains a <button>) -->
                         <button id="ai-daily-report-btn" class="btn btn-secondary !p-2" title="Get Daily AI Report">
                             <i data-lucide="clipboard-list" class="w-5 h-5 btn-text"></i>
                             <div class="loader hidden !w-5 !h-5"></div>
                         </button>
                         <!-- AI Meal Suggester (Changed to <a>) -->
                         <a id="ai-meal-suggester-btn" href="assets/nutrition/ai-meal-suggester.html" class="btn btn-secondary !p-2" title="AI Meal Suggester"><i data-lucide="lightbulb" class="w-5 h-5"></i></a>
                         <!-- AI Nutritionist Chat (Changed to <a>) -->
                         <a id="open-nutritionist-chat-btn" href="assets/nutrition/open-nutritionist-chat.html" class="btn btn-secondary !p-2" title="Chat with AI Nutritionist"><i data-lucide="message-circle" class="w-5 h-5"></i></a>
                     </div>
                 </div>
                <div id="daily-log-content" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500">No food logged yet.</p></div>
            </div>

            <!-- Favorites & Recipes (Order 4) -->
            <div class="content-card order-4">
                <h3 class="text-2xl font-bold mb-4">Favorites & Recipes</h3>
                <div id="saved-items-list" class="space-y-2 max-h-60 overflow-y-auto custom-scrollbar pr-2"><p class="text-gray-500 text-center">No saved items yet.</p></div>
            </div>

        </main>
    </div>

    <!--
      TEMPLATE FOR A NEW INGREDIENT ROW
    -->
    <template id="ingredient-row-template">
      <div class="scroll-item ingredient-row bg-input-bg rounded-lg space-y-2 p-3">
        <div class="flex items-end gap-2">
            <div class="flex-grow">
                <label class="form-label text-xs">Ingredient Name</label>
                <input type="text" list="favorite-foods-datalist" placeholder="e.g., Chicken" class="form-input ingredient-name text-sm !py-1.5" value="">
            </div>
            <div class="flex-shrink-0 w-16">
                <label class="form-label text-xs">Qty</label>
                <input type="number" min="0" placeholder="Qty" class="form-input ingredient-quantity text-sm !py-1.5" value="1">
            </div>
        </div>
        <div class="grid grid-cols-4 gap-2">
            <div><label class="form-label text-xs">Calories</label><input type="number" step="0.01" min="0" placeholder="kcal" class="form-input ingredient-calories text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Protein</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-protein text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Carbs</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-carbs text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Fat</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-fat text-xs !py-1.5" value=""></div>
        </div>
         <div class="grid grid-cols-4 gap-2">
            <div><label class="form-label text-xs">Sugar</label><input type="number" step="0.01" min="0" placeholder="g" class="form-input ingredient-sugar text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Sodium</label><input type="number" step="0.01" min="0" placeholder="mg" class="form-input ingredient-sodium text-xs !py-1.5" value=""></div>
            <div><label class="form-label text-xs">Potassium</label><input type="number" step="0.01" min="0" placeholder="mg" class="form-input ingredient-potassium text-xs !py-1.5" value=""></div>
            <div>
                <label class="form-label text-xs">Grams</label>
                <input type="number" placeholder="g" min="0" class="form-input ingredient-grams text-xs !py-1.5" value="">
            </div>
        </div>
        <div class="flex justify-between items-center gap-2">
            <div class="flex-shrink-0" style="width: 1.5rem; height: 1.5rem;"></div> <!-- Spacer -->
            <div class="flex-grow flex justify-center items-center gap-2">
                <button type="button" class="recipe-scan-btn btn btn-secondary !p-2 flex-shrink-0" title="Scan Ingredient"><i data-lucide="scan-line" class="w-4 h-4 pointer-events-none"></i></button>
                <button type="button" class="remove-ingredient-btn btn btn-secondary !p-2 flex-shrink-0" title="Remove Ingredient"><i data-lucide="x" class="w-4 h-4 pointer-events-none"></i></button>
                <button type="button" class="find-macros-ai-btn btn btn-secondary !p-2 flex-shrink-0" title="Find Macros with AI">
                    <i data-lucide="sparkles" class="w-4 h-4 pointer-events-none lucide-icon"></i>
                    <div class="loader hidden !w-4 !h-4"></div>
                </button>
            </div>
            <span class="ingredient-number">1</span> <!-- Ingredient number -->
        </div>
       </div>
    </template>
    <!-- End Template -->


    <!-- Extracted Compound Food Modal (Kept for now, though button links away) -->
    <div id="compound-food-modal" class="modal-backdrop" style="display: none;">
        <div class="modal-content">
            <button id="close-compound-food-modal-btn" class="absolute top-8 right-4 md:top-8 md:right-4 text-gray-400 hover:text-white text-5xl w-8 h-8 flex items-center justify-center z-10">&times;</button>
            <div class="flex-shrink-0 flex justify-between items-center mb-2">
                <div class="w-8 flex-shrink-0"></div> <!-- Spacer -->
                <input type="text" id="recipe-name-input" form="compound-food-form" class="form-input !py-1.5 text-1xl font-bold flex-grow text-center" required placeholder="Build Your Creation">
                <div class="w-8 flex-shrink-0"></div> <!-- Spacer -->
            </div>
            <div class="flex-grow overflow-y-auto custom-scrollbar pr-2 mb-4">
                <form id="compound-food-form" class="space-y-4">
                    <div class="border-gray-800">
                        <h3 class="font-semibold text-sm text-center mb-2">Ingredients</h3>
                        <div id="recipe-carousel-wrapper" class="carousel-wrapper">
                            <button id="recipe-prev-ingredient" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                            <div id="ingredient-list-container" class="horizontal-scroll-container recipe-carousel items-start border border-gray-700 rounded-lg p-2 section-disabled">
                                <!-- INGREDIENT ROWS Will be added here by JS -->
                            </div>
                            <div class="disabled-overlay">
                                <p class="flex items-center gap-2 text-sm"><i data-lucide="arrow-up" class="w-4 h-4 -mt-1"></i> Enter a name above to start</p>
                            </div>
                            <button id="recipe-next-ingredient" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                        </div>
                    </div>
                    <div id="recipe-totals-container" class="flex-shrink-0 border-gray-800 px-2 ">
                        <h3 class="text-lg font-semibold text-center mb-2">Total Macros</h3>
                        <div id="recipe-totals" class="grid grid-cols-4 gap-x-2 gap-y-3 text-center">
                            <div><p class="text-xs text-gray-400">Calories</p><p id="recipe-total-calories" class="font-bold text-sm">0</p></div>
                            <div><p class="text-xs text-gray-400">Protein</p><p class="font-bold text-sm"><span id="recipe-total-protein">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Carbs</p><p class="font-bold text-sm"><span id="recipe-total-carbs">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Fat</p><p class="font-bold text-sm"><span id="recipe-total-fat">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Grams</p><p id="recipe-total-grams" class="font-bold text-sm">0</p></div>
                            <div><p class="text-xs text-gray-400">Sugar</p><p class="font-bold text-sm"><span id="recipe-total-sugar">0</span>g</p></div>
                            <div><p class="text-xs text-gray-400">Sodium</p><p class="font-bold text-sm"><span id="recipe-total-sodium">0</span>mg</p></div>
                            <div><p class="text-xs text-gray-400">Potassium</p><p class="font-bold text-sm"><span id="recipe-total-potassium">0</span>mg</p></div>
                        </div>
                    </div>
                </form> <!-- End of Form -->
            </div> <!-- End of Scrollable Area -->
            <div class="flex-shrink-0 border-gray-800">
                <div class="grid grid-cols-2 gap-2 mt-2">
                    <button type="button" id="add-ingredient-btn" class="btn btn-secondary w-full !py-1 !text-sm" disabled><i data-lucide="plus"></i>Add Ingredient</button>
                    <button type="submit" form="compound-food-form" id="save-recipe-btn" class="btn btn-primary w-full !py-1 !text-sm">Save & Log Recipe</button>
                </div>
            </div>
        </div>
    </div>
    <!-- End Extracted Modal -->


    <!-- Modals -->

    <!-- Renamed and Unified AI Scanner Modal (Kept for now, though button links away) -->
    <div id="ai-scanner-modal" class="modal-backdrop" style="z-index: 60; display: none;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">AI Scanner</h2>
                <button id="close-ai-scanner-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div class="space-y-4">
                <div id="ai-scanner-initial-options" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <label for="ai-upload-photo-input" class="btn btn-secondary cursor-pointer"><i data-lucide="upload"></i>Upload</label>
                    <input type="file" id="ai-upload-photo-input" class="hidden" accept="image/*" multiple>
                    <button id="start-ai-camera-btn" class="btn bg-white text-black hover:bg-gray-200"><i data-lucide="camera"></i>Live Camera</button>
                </div>
                <div id="ai-live-camera-container" class="hidden space-y-2">
                    <video id="ai-camera-video" class="w-full rounded-lg border border-border-color" autoplay playsinline></video>
                    <canvas id="ai-camera-canvas" class="hidden"></canvas> <!-- For capturing frames -->
                    <button id="capture-ai-photo-btn" class="btn btn-primary w-full">Capture Photo</button>
                    <button id="stop-ai-camera-btn" class="btn btn-danger w-full">Close Camera</button>
                </div>
                <p id="ai-scanner-status" class="text-center text-secondary-text text-sm min-h-[1.25rem]"></p>
                <div id="ai-scanner-carousel-wrapper" class="carousel-wrapper">
                    <button id="ai-scanner-prev" type="button" class="carousel-btn carousel-prev"><i data-lucide="chevron-left"></i></button>
                    <div id="ai-scanner-results-container" class="horizontal-scroll-container scanner-carousel mt-4 min-h-[220px] !flex !flex-row !flex-nowrap">
                        <!-- Results injected here -->
                    </div>
                    <button id="ai-scanner-next" type="button" class="carousel-btn carousel-next"><i data-lucide="chevron-right"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- START: RE-ADDED MODALS -->

    <!-- AI Nutritionist Chat Modal (Kept for now, though button links away) -->
    <div id="ai-nutritionist-modal" class="modal-backdrop" style="z-index: 70; display: none;">
        <div class="modal-content !h-[90vh] !max-h-[800px] flex flex-col">
            <div class="flex justify-between items-center mb-4 pb-4 border-b border-border-color">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="bot" class="w-6 h-6 text-blue-400"></i>AI Nutritionist</h2>
                <button id="close-ai-nutritionist-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-chat-history" class="flex-grow overflow-y-auto space-y-4 pr-2 custom-scrollbar">
                <!-- Chat history will be rendered here -->
            </div>
            <div class="mt-4 pt-4 border-t border-border-color flex gap-2">
                <input type="text" id="ai-chat-input" class="form-input flex-grow" placeholder="Ask about your diet...">
                <button id="ai-chat-send-btn" class="btn btn-primary !p-3"><i data-lucide="send" class="w-5 h-5"></i></button>
            </div>
        </div>
    </div>

    <!-- Edit Favorite Modal -->
    <div id="edit-favorite-modal" class="modal-backdrop" style="display: none;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Edit Favorite Food</h2>
                <button id="close-edit-favorite-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <form id="edit-favorite-form" class="space-y-4">
                <div>
                    <label for="edit-fav-food-name" class="form-label">Food Name (100g serving)</label>
                    <input type="text" id="edit-fav-food-name" class="form-input mt-1" required>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-calories" class="form-label">Calories</label>
                        <input type="number" step="0.01" id="edit-fav-food-calories" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-protein" class="form-label">Protein (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-protein" class="form-input mt-1" required>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="edit-fav-food-carbs" class="form-label">Carbs (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-carbs" class="form-input mt-1" required>
                    </div>
                    <div>
                        <label for="edit-fav-food-fat" class="form-label">Fat (g)</label>
                        <input type="number" step="0.01" id="edit-fav-food-fat" class="form-input mt-1" required>
                    </div>
                </div>
                <!-- Optional micronutrients -->
                <details class="pt-2">
                    <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Optional Macros (per 100g)</summary>
                    <div class="grid grid-cols-3 gap-3 pt-3">
                        <div>
                            <label for="edit-fav-food-sugar" class="form-label text-xs">Sugar (g)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sugar" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-sodium" class="form-label text-xs">Sodium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-sodium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                        <div>
                            <label for="edit-fav-food-potassium" class="form-label text-xs">Potassium (mg)</label>
                            <input type="number" step="0.01" id="edit-fav-food-potassium" class="form-input mt-1 !py-1.5 text-sm">
                        </div>
                    </div>
                </details>
                <button type="submit" class="btn btn-primary w-full mt-4">Save Changes</button>
            </form>
        </div>
    </div>

    <!-- Generic Alert Modal -->
    <div id="alert-modal" class="modal-backdrop" style="z-index: 80; display: none;">
        <div class="modal-content">
            <h2 id="alert-modal-title" class="text-2xl font-bold mb-4">Alert</h2>
            <p id="alert-modal-text" class="text-gray-300 mb-6"></p>
            <button id="alert-modal-ok-btn" class="btn btn-primary w-full">OK</button>
        </div>
    </div>

    <!-- Generic Confirm Modal -->
    <div id="confirm-modal" class="modal-backdrop" style="z-index: 80; display: none;">
        <div class="modal-content">
            <h2 id="confirm-modal-title" class="text-2xl font-bold mb-4">Confirm</h2>
            <p id="confirm-modal-text" class="text-gray-300 mb-6"></p>
            <div class="flex gap-4">
                <button id="confirm-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="confirm-modal-confirm-btn" class="btn btn-danger w-full">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Generic Prompt Modal -->
    <div id="prompt-modal" class="modal-backdrop" style="z-index: 80; display: none;">
        <div class="modal-content">
            <h2 id="prompt-modal-title" class="text-2xl font-bold mb-4">Input</h2>
            <p id="prompt-modal-text" class="text-gray-300 mb-4"></p>
            <!-- 
                CHANGE 2: Changed type="text" to type="number" to provide a number pad
                on mobile devices for both water goal and glass size prompts.
            -->
            <input type="number" id="prompt-modal-input" class="form-input w-full" min="0" step="1">
            <div class="flex gap-4 mt-6">
                <button id="prompt-modal-cancel-btn" class="btn btn-secondary w-full">Cancel</button>
                <button id="prompt-modal-ok-btn" class="btn btn-primary w-full">OK</button>
            </div>
        </div>
    </div>

    <!-- AI Daily Report Modal (This one IS used) -->
    <div id="ai-report-modal" class="modal-backdrop" style="display: none;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="clipboard-list" class="w-5 h-5 text-blue-400"></i>Daily AI Report</h2>
                <button id="close-ai-report-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <div id="ai-report-modal-text" class="text-gray-300 max-h-60 overflow-y-auto custom-scrollbar pr-2"></div>
            <button id="ai-report-modal-ok-btn" class="btn btn-primary w-full mt-6">Got it</button>
        </div>
    </div>

    <!-- AI Meal Suggester Modal (Kept for now, though button links away) -->
    <div id="ai-suggester-modal" class="modal-backdrop" style="display: none;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">AI Meal Suggester</h2>
                <button id="close-ai-suggester-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Enter ingredients you have, and the AI will suggest a quick, healthy meal.</p>
            <div>
                <label for="ai-ingredients-input" class="form-label">Your Ingredients</label>
                <textarea id="ai-ingredients-input" rows="3" class="form-input mt-1" placeholder="e.g., chicken breast, rice, broccoli, olive oil"></textarea>
            </div>
            <button id="ai-suggestion-btn" class="btn btn-secondary w-full mt-4"><span class="btn-text">Generate Ideas</span><div class="loader hidden"></div></button>
            <div id="ai-suggestions-output" class="mt-4 space-y-3"></div>
        </div>
    </div>

    <!-- AI Macro Swap Modal (This one IS used) -->
    <div id="ai-macro-swap-modal" class="modal-backdrop" style="display: none;">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold flex items-center gap-2"><i data-lucide="replace" class="w-5 h-5 text-blue-400"></i>AI Macro Swap</h2>
                <button id="close-ai-macro-swap-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            <p class="text-gray-400 mb-4 text-sm">Healthier alternatives for <strong id="ai-swap-food-name" class="text-white">...</strong></p>
            <div id="ai-macro-swap-output" class="space-y-3 min-h-[150px]">
                <!-- Suggestions will be injected here -->
                <div class="loader mx-auto"></div>
            </div>
        </div>
    </div>

    <!-- END: RE-ADDED MODALS -->

     <!-- Undo Toast -->
    <div id="undo-toast" class="fixed bottom-20 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg flex items-center gap-4 transform translate-y-24 opacity-0 transition-all duration-300 z-[100]">
        <span id="undo-toast-text"></span>
        <button id="undo-toast-btn" class="font-bold text-blue-400 hover:text-blue-300">Undo</button>
    </div>


    <!-- FIX 3: Added Footer Placeholder -->
    <div id="footer-placeholder"></div>


    <!-- Hidden helper for html5-qrcode library -->
    <div id="barcode-reader-hidden-helper" class="hidden"></div>


    <!-- 
      FIX 4: Added the header/footer loading script from other pages.
      The original script from nutrition.html is wrapped in 
      an `initializeNutritionPage()` function and called from here.
    -->
    <script>
        // --- Load Header and Footer ---
        async function loadComponent(url, placeholderId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}: ${response.statusText}`);
                const text = await response.text();
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = text;
                }
            } catch (error) {
                console.error(`Error loading component from ${url}:`, error);
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = `<p class="text-red-500 text-center">Error loading component.</p>`;
                }
            }
        }

        async function initializeLayout() {
            // Load header and footer from the 'assets' directory
            await Promise.all([
                loadComponent('assets/header.html', 'header-placeholder'),
                loadComponent('assets/footer.html', 'footer-placeholder')
            ]);
            lucide.createIcons(); // Re-render icons after loading components

            // --- Set Active Footer Link ---
            const currentPage = 'nutrition'; // This page is 'nutrition'
            const navLinks = document.querySelectorAll('#mobile-footer-nav .nav-link');
            navLinks.forEach(link => {
                if (link.dataset.page === currentPage) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });

            // --- Initialize Page Specific JS ---
            initializeNutritionPage();
        }
        // --- End Load Header and Footer ---


        // --- Original script from nutrition.html (wrapped in a function) ---
        function initializeNutritionPage() {
            // --- STATE MANAGEMENT ---
            let allDailyLogs = {};
            let goals = { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
            let userProfile = { goal: 'maintain weight', waterServingSize: 250 };
            let favoriteFoods = [];
            let savedRecipes = [];
            let editingFoodLogIndex = null;
            let editingFavoriteFoodName = null;
            let confirmCallback = null;
            let promptCallback = null;
            let viewDate = new Date();
            viewDate.setHours(0, 0, 0, 0);
            let foodCameraStream = null;
            let aiBaseMacros = null;
            let chatHistory = [];
            let lastScannedBarcode = { code: null, time: 0 };
            let undoTimeout = null;
            let lastAction = null;
            let lastWaterLogAmount = 0; // NEW: Store last water amount for undo
            let openModalCount = 0;
            let activeRecipeScanBtn = null; // Store the button that triggered the scanner for ingredients
            let html5QrCode = null; // Store the scanner instance

            // --- CORE & HELPER FUNCTIONS ---
            function dateToKey(date) { return date.toISOString().split('T')[0]; }
            function capitalizeWords(str) { if (!str) return ''; return str.replace(/\b\w/g, char => char.toUpperCase()); }

            function getDayLog(date) {
                const key = dateToKey(date);
                if (!allDailyLogs[key]) {
                    allDailyLogs[key] = { entries: [], water: 0 };
                }
                // Ensure water exists even if entries array is created
                if (typeof allDailyLogs[key].water === 'undefined') {
                     allDailyLogs[key].water = 0;
                }
                return allDailyLogs[key];
            }

            function getCurrentDayLogEntries() { return getDayLog(viewDate).entries; }

            // --- GEMINI API ---
            const getApiUrl = (model, action = 'generateContent') => {
                const apiKey = "AIzaSyDY48xF1byvU05kS9qKvN8iyrIR3hheP8w"; // API Key is handled by the environment
                return `https://generativelanguage.googleapis.com/v1beta/models/${model}:${action}?key=${apiKey}`;
            };

            // Helper function to make API calls with exponential backoff
            async function fetchWithBackoff(apiUrl, payload, maxRetries = 3) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            const result = await response.json();
                           // Check for expected data in the response structure
                            const hasText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                            const hasImageData = result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                            const hasStructuredResponse = payload.generationConfig?.responseMimeType === "application/json";

                           if (hasText || hasImageData || hasStructuredResponse) {
                                return result; // Successful and valid response structure
                            } else {
                                console.warn("API response structure unexpected, but status OK:", result);
                                // Check for blockReason
                                const blockReason = result.promptFeedback?.blockReason;
                                if (blockReason) {
                                    throw new Error(`API request blocked due to: ${blockReason}.`);
                                }
                                if (i === maxRetries - 1) throw new Error("Invalid API response format after retries.");
                            }
                        } else if (response.status === 429 || response.status >= 500) { // Retry on rate limit or server errors
                            if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after ${maxRetries} attempts.`);
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; // Exponential backoff with jitter
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else { // Don't retry for other client errors (4xx)
                            const errorText = await response.text();
                            console.error(`API Error Response (${response.status}):`, errorText);
                            throw new Error(`API Error: ${response.status} - ${errorText || 'See console for details.'}`);
                        }
                    } catch (error) {
                        console.error(`Fetch attempt ${i + 1} failed:`, error);
                        if (i === maxRetries - 1) throw error; // Re-throw final error
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                throw new Error("API call failed after all retries.");
            }
            // --- END GEMINI API ---

            // --- Modal show/hide functions ---
            function showModal(modalElement) {
                if (!modalElement) return; // Add safety check
                modalElement.style.display = 'flex';
                if (openModalCount === 0) {
                    document.body.style.overflow = 'hidden';
                }
                openModalCount++;
            }
            function hideModal(modalElement) {
                if (!modalElement) return; // Add safety check
                modalElement.style.display = 'none';
                openModalCount--;
                if (openModalCount <= 0) {
                    document.body.style.overflow = '';
                    openModalCount = 0; // Failsafe
                }
            }
            // --- END Modal functions ---

            function showCustomAlert(title, text) { if (ui.alertModal.style.display === 'flex') return; ui.alertModalTitle.textContent = title; ui.alertModalText.textContent = text; showModal(ui.alertModal); }
            function showConfirmModal(title, text, onConfirm) { if (ui.confirmModal.style.display === 'flex') return; ui.confirmModalTitle.textContent = title; ui.confirmModalText.textContent = text; confirmCallback = onConfirm; showModal(ui.confirmModal); }
            function showPromptModal(title, text, defaultValue, onConfirm) { if (ui.promptModal.style.display === 'flex') return; ui.promptModalTitle.textContent = title; ui.promptModalText.textContent = text; ui.promptModalInput.value = defaultValue; promptCallback = onConfirm; showModal(ui.promptModal); ui.promptModalInput.focus(); ui.promptModalInput.select(); }

            function saveData() {
                localStorage.setItem('fitTrackAI_allDailyLogs', JSON.stringify(allDailyLogs));
                localStorage.setItem('fitTrackAI_userProfile', JSON.stringify(userProfile));
                localStorage.setItem('fitTrackAI_favoriteFoods', JSON.stringify(favoriteFoods));
                localStorage.setItem('fitTrackAI_savedRecipes', JSON.stringify(savedRecipes));
                localStorage.setItem('fitTrackAI_goals', JSON.stringify(goals));
                localStorage.setItem('fitTrackAI_chatHistory', JSON.stringify(chatHistory));
            }

            function loadData() {
                let logs = JSON.parse(localStorage.getItem('fitTrackAI_allDailyLogs')) || {};
                // Migration for old data structure
                for(const date in logs) {
                    if(Array.isArray(logs[date])) {
                        logs[date] = {
                            entries: logs[date].filter(item => item.name !== 'Water'), // Remove old water entries
                            water: 0
                        }
                    }
                    // Ensure water exists after migration or for new logs
                     if (typeof logs[date].water === 'undefined') {
                         logs[date].water = 0;
                     }
                }
                allDailyLogs = logs;

                chatHistory = JSON.parse(localStorage.getItem('fitTrackAI_chatHistory')) || [];
                userProfile = JSON.parse(localStorage.getItem('fitTrackAI_userProfile')) || { goal: 'maintain weight', waterServingSize: 250 };
                goals = JSON.parse(localStorage.getItem('fitTrackAI_goals')) || { calories: 2000, protein: 150, carbs: 225, fat: 60, sugar: 50, sodium: 2300, potassium: 3500, water: 2500 };
                savedRecipes = JSON.parse(localStorage.getItem('fitTrackAI_savedRecipes')) || [];
                favoriteFoods = JSON.parse(localStorage.getItem('fitTrackAI_favoriteFoods')) || [];

                 // Ensure favorite foods have all keys, defaulting to 0
                favoriteFoods = favoriteFoods.map(fav => ({
                    name: fav.name || 'Unnamed',
                    calories: fav.calories || 0,
                    protein: fav.protein || 0,
                    carbs: fav.carbs || 0,
                    fat: fav.fat || 0,
                    sugar: fav.sugar || 0,
                    sodium: fav.sodium || 0,
                    potassium: fav.potassium || 0,
                }));
            }

            // --- UI ELEMENT DEFINITIONS ---
            const ui = {
                foodNameInput: document.getElementById('food-name-input'), foodBrandInput: document.getElementById('food-brand-input'), foodServingsInput: document.getElementById('food-servings-input'), foodGramsInput: document.getElementById('food-grams-input'), logMealForm: document.getElementById('log-meal-form'), addFoodBtn: document.getElementById('add-food-btn'), addFoodError: document.getElementById('add-food-error'), dailyLogContentDiv: document.getElementById('daily-log-content'),

                foodScannerModal: document.getElementById('ai-scanner-modal'),
                closeFoodScannerModalBtn: document.getElementById('close-ai-scanner-modal-btn'),
                uploadPhotoInput: document.getElementById('ai-upload-photo-input'),
                scannerResultsContainer: document.getElementById('ai-scanner-results-container'),
                foodScannerStatus: document.getElementById('ai-scanner-status'),

                confirmModal: document.getElementById('confirm-modal'), confirmModalTitle: document.getElementById('confirm-modal-title'), confirmModalText: document.getElementById('confirm-modal-text'), confirmModalCancelBtn: document.getElementById('confirm-modal-cancel-btn'), confirmModalConfirmBtn: document.getElementById('confirm-modal-confirm-btn'), alertModal: document.getElementById('alert-modal'), alertModalTitle: document.getElementById('alert-modal-title'), alertModalText: document.getElementById('alert-modal-text'), alertModalOkBtn: document.getElementById('alert-modal-ok-btn'),

                aiMacroSwapBtn: document.getElementById('ai-macro-swap-btn'),

                savedItemsListDiv: document.getElementById('saved-items-list'), promptModal: document.getElementById('prompt-modal'), promptModalTitle: document.getElementById('prompt-modal-title'), promptModalText: document.getElementById('prompt-modal-text'), promptModalInput: document.getElementById('prompt-modal-input'), promptModalCancelBtn: document.getElementById('prompt-modal-cancel-btn'), promptModalOkBtn: document.getElementById('prompt-modal-ok-btn'), editFavoriteModal: document.getElementById('edit-favorite-modal'), closeEditFavoriteModalBtn: document.getElementById('close-edit-favorite-modal-btn'), editFavoriteForm: document.getElementById('edit-favorite-form'), dailySummaryCard: document.getElementById('daily-summary-card'), dayViewTitleSpan: document.getElementById('day-view-title-span'), dayViewDateSpan: document.getElementById('day-view-date-span'), aiDailyReportBtn: document.getElementById('ai-daily-report-btn'),
                aiReportModal: document.getElementById('ai-report-modal'), aiReportModalText: document.getElementById('ai-report-modal-text'), closeAiReportModalBtn: document.getElementById('close-ai-report-modal-btn'), aiReportModalOkBtn: document.getElementById('ai-report-modal-ok-btn'),
                addWaterBtn: document.getElementById('add-water-btn'),
                waterFill: document.getElementById('water-fill'), // NEW: Water fill UI
                waterSwipeBgLeft: document.getElementById('water-swipe-bg-left'), // NEW
                waterSwipeBgRight: document.getElementById('water-swipe-bg-right'), // NEW
                waterSwipeContent: document.getElementById('water-swipe-content'), // NEW

                openNutritionistChatBtn: document.getElementById('open-nutritionist-chat-btn'), // This is an <a> tag
                aiNutritionistModal: document.getElementById('ai-nutritionist-modal'), // This modal is still in the HTML
                closeAiNutritionistModalBtn: document.getElementById('close-ai-nutritionist-modal-btn'),
                aiChatHistory: document.getElementById('ai-chat-history'),
                aiChatInput: document.getElementById('ai-chat-input'),
                aiChatSendBtn: document.getElementById('ai-chat-send-btn'),

                foodScannerInitialOptions: document.getElementById('ai-scanner-initial-options'),
                liveCameraContainer: document.getElementById('ai-live-camera-container'),
                startFoodCameraBtn: document.getElementById('start-ai-camera-btn'),
                stopFoodCameraBtn: document.getElementById('stop-ai-camera-btn'),
                captureFoodPhotoBtn: document.getElementById('capture-ai-photo-btn'),
                foodCameraVideo: document.getElementById('ai-camera-video'),
                foodCameraCanvas: document.getElementById('ai-camera-canvas'),

                aiMealSuggesterBtn: document.getElementById('ai-meal-suggester-btn'), // This is an <a> tag
                aiSuggesterModal: document.getElementById('ai-suggester-modal'), // This modal is still in the HTML
                closeAiSuggesterModalBtn: document.getElementById('close-ai-suggester-modal-btn'),
                aiIngredientsInput: document.getElementById('ai-ingredients-input'),
                aiSuggestionBtn: document.getElementById('ai-suggestion-btn'),
                aiSuggestionsOutput: document.getElementById('ai-suggestions-output'),
                undoToast: document.getElementById('undo-toast'),
                undoToastBtn: document.getElementById('undo-toast-btn'),
                undoToastText: document.getElementById('undo-toast-text'),
                foodScannerCarouselWrapper: document.getElementById('ai-scanner-carousel-wrapper'),
                foodScannerPrev: document.getElementById('ai-scanner-prev'),
                foodScannerNext: document.getElementById('ai-scanner-next'),

                scanCombinedBtn: document.getElementById('scan-combined-btn'), // This is an <a> tag

                aiMacroSwapModal: document.getElementById('ai-macro-swap-modal'),
                closeAiMacroSwapModalBtn: document.getElementById('close-ai-macro-swap-modal-btn'),
                aiMacroSwapOutput: document.getElementById('ai-macro-swap-output'),
                aiSwapFoodName: document.getElementById('ai-swap-food-name'),

                // NEW: Compound Food Modal UI
                compoundFoodModal: document.getElementById('compound-food-modal'), // This modal is still in the HTML
                closeCompoundFoodModalBtn: document.getElementById('close-compound-food-modal-btn'),
                openCompoundFoodModalBtn: document.getElementById('open-compound-food-modal-btn'), // This is an <a> tag
                addIngredientBtn: document.getElementById('add-ingredient-btn'),
                ingredientListContainer: document.getElementById('ingredient-list-container'),
                compoundFoodForm: document.getElementById('compound-food-form'),
                ingredientTemplate: document.getElementById('ingredient-row-template'),
                recipeNameInput: document.getElementById('recipe-name-input'),
                recipeCarouselPrev: document.getElementById('recipe-prev-ingredient'),
                recipeCarouselNext: document.getElementById('recipe-next-ingredient')
            };

            // --- START: MODAL EVENT LISTENERS (FIX) ---
            // Attaching listeners to close buttons that were missing
            
            // Alert Modal
            if (ui.alertModalOkBtn) {
                ui.alertModalOkBtn.addEventListener('click', () => hideModal(ui.alertModal));
            }

            // Confirm Modal
            if (ui.confirmModalCancelBtn) {
                ui.confirmModalCancelBtn.addEventListener('click', () => {
                    hideModal(ui.confirmModal);
                    confirmCallback = null; // Just clear the callback
                });
            }
            if (ui.confirmModalConfirmBtn) {
                ui.confirmModalConfirmBtn.addEventListener('click', () => {
                    hideModal(ui.confirmModal);
                    if (typeof confirmCallback === 'function') {
                        confirmCallback(); // Just call the saved callback
                    }
                    confirmCallback = null;
                });
            }

            // Prompt Modal
            if (ui.promptModalCancelBtn) {
                ui.promptModalCancelBtn.addEventListener('click', () => {
                    hideModal(ui.promptModal);
                    if (typeof promptCallback === 'function') {
                        promptCallback(null); // Pass null for cancel
                    }
                    promptCallback = null;
                });
            }
            if (ui.promptModalOkBtn) {
                ui.promptModalOkBtn.addEventListener('click', () => {
                    hideModal(ui.promptModal);
                    if (typeof promptCallback === 'function') {
                        promptCallback(ui.promptModalInput.value); // Pass the input value
                    }
                    promptCallback = null;
                });
            }

            // Edit Favorite Modal
            if (ui.closeEditFavoriteModalBtn) {
                ui.closeEditFavoriteModalBtn.addEventListener('click', () => {
                    hideModal(ui.editFavoriteModal);
                    editingFavoriteFoodName = null; // Clear editing state
                });
            }
            
            // AI Scanner Modal
            if (ui.closeFoodScannerModalBtn) {
                ui.closeFoodScannerModalBtn.addEventListener('click', () => {
                    hideModal(ui.foodScannerModal);
                    // Note: The stopFoodCameraStream function doesn't seem to be defined.
                    // If camera logic is added, it should be called here.
                });
            }

            // --- END: MODAL EVENT LISTENERS (FIX) ---


            // --- CHART.JS SETUP ---
            const macroCtx = document.getElementById('macro-chart').getContext('2d');
            let macroChart = new Chart(macroCtx, { type: 'doughnut', data: { labels: ['Protein', 'Carbs', 'Fat'], datasets: [{ data: [1, 1, 1], backgroundColor: ['#3b82f6', '#10b981', '#ef4444'], borderWidth: 0, hoverOffset: 4 }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '70%', plugins: { legend: { display: false } } } });

            // --- RENDER & DATA FLOW FUNCTIONS ---
            function updateSummary() {
                const dayLog = getDayLog(viewDate);
                const currentDayLogEntries = dayLog.entries;

                const totals = currentDayLogEntries.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });

                document.getElementById('current-calories').textContent = totals.calories.toFixed(0); document.getElementById('goal-calories').textContent = goals.calories;
                document.getElementById('current-protein').textContent = totals.protein.toFixed(1); document.getElementById('goal-protein').textContent = goals.protein;
                document.getElementById('current-carbs').textContent = totals.carbs.toFixed(1); document.getElementById('goal-carbs').textContent = goals.carbs;
                document.getElementById('current-fat').textContent = totals.fat.toFixed(1); document.getElementById('goal-fat').textContent = goals.fat;
                document.getElementById('current-sugar').textContent = totals.sugar.toFixed(1); document.getElementById('goal-sugar').textContent = goals.sugar;
                document.getElementById('current-sodium').textContent = totals.sodium.toFixed(0); document.getElementById('goal-sodium').textContent = goals.sodium;
                document.getElementById('current-potassium').textContent = totals.potassium.toFixed(0); document.getElementById('goal-potassium').textContent = goals.potassium;
                document.getElementById('current-water').textContent = dayLog.water; document.getElementById('goal-water').textContent = goals.water;

                // Update water fill
                const waterPercent = Math.min(100, (dayLog.water / (goals.water || 1)) * 100);
                if (ui.waterFill) {
                    ui.waterFill.style.height = `${waterPercent}%`;
                }

                const macroSum = totals.protein + totals.carbs + totals.fat;
                macroChart.data.datasets[0].data = macroSum > 0 ? [totals.protein, totals.carbs, totals.fat] : [1, 1, 1];
                macroChart.update();
            }

            function renderDailyLog() {
                const currentDayLogEntries = getCurrentDayLogEntries();
                if (currentDayLogEntries.length === 0) { ui.dailyLogContentDiv.innerHTML = '<p class="text-gray-500">No food logged yet.</p>'; return; }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());
                 ui.dailyLogContentDiv.innerHTML = currentDayLogEntries.map((item, index) => `
                    <div class="swipe-item rounded-lg" data-index="${index}" data-type="log" data-name="${item.name}">
                        <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                    <div>
                                        <p class="font-medium">${item.servings}x ${item.name} ${item.grams > 0 ? `(${(item.grams / (item.servings || 1)).toFixed(0)}g/serv)` : ''}</p>
                                        <p class="text-sm text-gray-400">${item.calories?.toFixed(0) || 0}kcal | ${item.protein?.toFixed(1) || 0}p | ${item.carbs?.toFixed(1) || 0}c | ${item.fat?.toFixed(1) || 0}f</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');
                lucide.createIcons();
            }

            function renderSavedItemsList() {
                const combinedList = [
                    ...savedRecipes.map((item, index) => ({...item, type: 'recipe', originalIndex: index})),
                    ...favoriteFoods.map((item, index) => ({...item, type: 'food', originalIndex: index}))
                ].sort((a,b) => a.name.localeCompare(b.name));

                if (combinedList.length === 0) {
                    ui.savedItemsListDiv.innerHTML = '<p class="text-gray-500 text-center">No saved items yet.</p>';
                    return;
                }
                const isFavorite = (itemName) => favoriteFoods.some(fav => fav.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.some(rec => rec.name.toLowerCase() === itemName.toLowerCase());

                // Update datalist for autocompletion
                 const datalist = document.getElementById('favorite-foods-datalist');
                 datalist.innerHTML = combinedList.map(item => `<option value="${item.name}"></option>`).join('');

                ui.savedItemsListDiv.innerHTML = combinedList.map(item => `
                    <div class="swipe-item rounded-lg" data-name="${item.name}" data-type="${item.type}" data-index="${item.originalIndex}">
                         <div class="swipe-actions">
                            <div class="swipe-action-container left"><div class="action delete"><i data-lucide="trash-2" class="pointer-events-none"></i><span class="ml-2 pointer-events-none">Delete</span></div></div>
                            <div class="swipe-action-container right"><div class="action edit"><span class="mr-2 pointer-events-none">Edit</span><i data-lucide="pencil" class="pointer-events-none"></i></div></div>
                        </div>
                        <div class="swipe-content p-3 rounded-lg border border-transparent hover:border-gray-700"> <!-- Added border for hover -->
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                   ${isFavorite(item.name) ? '<i data-lucide="star" class="w-4 h-4 text-yellow-400 fill-yellow-400 flex-shrink-0"></i>' : '<div class="w-4 h-4 flex-shrink-0"></div>'}
                                   <p class="font-medium">${item.name}</p>
                                   ${item.type === 'recipe' ? '<span class="text-xs bg-blue-500 text-white rounded-full px-2 py-0.4">Recipe</span>' : ''}
                                </div>
                                <button class="log-item-btn btn btn-secondary !p-2" title="Log Item"><i data-lucide="plus" class="w-4 h-4 pointer-events-none"></i></button>
                            </div>
                        </div>
                    </div>`).join('');
                lucide.createIcons();
            }


            function fullRender() {
                updateSummary();
                renderDailyLog();
                renderSavedItemsList();
                lucide.createIcons();
            }

            async function getDailyLogAIReport() {
                const btn = ui.aiDailyReportBtn;
                if (btn.disabled) return;

                const icon = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                if (icon) icon.style.display = 'none';
                if (loader) loader.classList.remove('hidden');
                btn.disabled = true;

                const dateKey = dateToKey(viewDate);
                const dayLog = getDayLog(viewDate);
                const currentLog = dayLog.entries;

                if (currentLog.length === 0 && dayLog.water === 0) { // Check water too
                    showCustomAlert('No Data', `There is no food or water logged for ${dateKey}.`);
                    if (loader) loader.classList.add('hidden');
                    if (icon) icon.style.display = 'inline-block';
                    btn.disabled = false;
                    return;
                }

                const totals = currentLog.reduce((acc, item) => { acc.calories += item.calories || 0; acc.protein += item.protein || 0; acc.carbs += item.carbs || 0; acc.fat += item.fat || 0; acc.sugar += item.sugar || 0; acc.sodium += item.sodium || 0; acc.potassium += item.potassium || 0; return acc; }, { calories: 0, protein: 0, carbs: 0, fat: 0, sugar: 0, sodium: 0, potassium: 0 });
                const goalData = goals;

                ui.aiReportModalText.textContent = 'Generating personalized report...';
                ui.aiReportModalText.classList.remove('text-red-400');
                showModal(ui.aiReportModal);

                const systemPrompt = `You are a friendly but expert nutrition coach. Provide a brief, actionable analysis of the user's daily food log. 1. Analyze the logged data against the goals. 2. Evaluate macro distribution (Protein, Carbs, Fat) and key micronutrients (Sodium/Potassium/Sugar). 3. Evaluate water intake. 4. Provide a concise summary (1-2 sentences). 5. Offer one specific, actionable tip for improvement/maintenance based on the biggest deviation or goal. Keep the report readable, using markdown bold for key stats, and keep the total response under 100 words.`;
                const userQuery = `Analyze the following log data for ${dateKey}: --- Logged Data --- Total Calories: ${totals.calories.toFixed(0)} kcal, Protein: ${totals.protein.toFixed(1)} g, Carbs: ${totals.carbs.toFixed(1)} g, Fat: ${totals.fat.toFixed(1)} g, Sugar: ${totals.sugar.toFixed(1)} g, Sodium: ${totals.sodium.toFixed(0)} mg, Potassium: ${totals.potassium.toFixed(0)} mg. Water: ${dayLog.water} ml. --- Daily Goals --- Calorie Goal: ${goalData.calories} kcal, Protein Goal: ${goalData.protein} g, Carb Goal: ${goalData.carbs} g, Fat Goal: ${goalData.fat} g, Sugar Limit: ${goalData.sugar} g, Sodium Limit: ${goalData.sodium} mg, Potassium Target: ${goalData.potassium} mg, Water Target: ${goalData.water} ml.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                     contents: [{ parts: [{ text: userQuery }] }],
                     tools: [{ "google_search": {} }],
                     systemInstruction: { parts: [{ text: systemPrompt }] }
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    ui.aiReportModalText.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                } catch (error) {
                    console.error("AI Report Error:", error);
                    hideModal(ui.aiReportModal);
                    showCustomAlert("AI Error", `Sorry, the AI coach couldn't generate a report. ${error.message}`);
                } finally {
                    btn.disabled = false;
                    if (loader) loader.classList.add('hidden');
                    if (icon) icon.style.display = 'inline-block';
                }
            }


            function updateDayView(date) {
                viewDate = date; const today = new Date(); today.setHours(0, 0, 0, 0);
                const dateKey = dateToKey(date), isToday = dateKey === dateToKey(today);
                ui.dayViewTitleSpan.textContent = isToday ? 'Today' : date.toLocaleDateString(undefined, { weekday: 'long' });
                ui.dayViewDateSpan.textContent = date.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
                fullRender();
            }

            async function getMacrosFromAI(foodName, brand) {
                let prompt = `Provide nutritional information for 100g of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `. Respond with only a valid JSON object containing all fields for 100 grams: "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Also include a "servingGrams": 100 field. If it's a food that is hard to quantify, like "salad", provide a reasonable estimate for 100g.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { 
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ "google_search": {} }], // Add grounding
                    generationConfig: { responseMimeType: "application/json" } 
                };
                 try {
                     const result = await fetchWithBackoff(apiUrl, payload);
                     if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                     return JSON.parse(result.candidates[0].content.parts[0].text);
                 } catch (error) {
                      console.error("getMacrosFromAI Error:", error);
                      throw error;
                 }
            }

            async function getPartialMacrosFromAI(foodName, brand, knownMacros) {
                let knownMacrosString = Object.entries(knownMacros).map(([key, value]) => `${key}: ${value}`).join(', ');
                let prompt = `For a standard single serving of "${foodName}"`;
                if (brand) prompt += ` from the brand "${brand}"`;
                prompt += `, we know it has the following values: ${knownMacrosString}. Based on this, estimate the *missing* nutritional values. Respond with only a valid JSON object containing a *complete* set of fields for ONE standard serving: "servingGrams", "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium". Use the provided values as facts and fill in the rest with reasonable estimates.`;

                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { 
                    contents: [{ parts: [{ text: prompt }] }],
                    tools: [{ "google_search": {} }], // Add grounding
                    generationConfig: { responseMimeType: "application/json" } 
                };

                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getPartialMacrosFromAI Error:", error);
                    throw error;
                }
            }
            function toggleFavorite(itemName) {
                if (savedRecipes.some(r => r.name.toLowerCase() === itemName.toLowerCase())) {
                    showCustomAlert("Action Not Allowed", "Recipes are automatically favorited and cannot be unfavorited.");
                    return;
                }
                const favIndex = favoriteFoods.findIndex(fav => fav.name.toLowerCase() === itemName.toLowerCase());
                if (favIndex > -1) {
                    favoriteFoods.splice(favIndex, 1);
                } else {
                     const logItem = getCurrentDayLogEntries().find(item => item.name.toLowerCase() === itemName.toLowerCase()) || savedRecipes.find(item => item.name.toLowerCase() === itemName.toLowerCase());
                     if (!logItem) {
                         showCustomAlert("Error", "Could not find item to favorite.");
                         return;
                     }
                    const totalGrams = logItem.grams || 0;
                    const servings = logItem.servings || 1;
                    if (totalGrams <= 0 || servings <= 0) {
                        showCustomAlert("Cannot Favorite", "Cannot favorite an item with 0 grams to calculate base macros.");
                        return;
                    }
                    const perServingGrams = totalGrams / servings;
                    const ratio = 100 / perServingGrams;

                    favoriteFoods.push({
                        name: logItem.name,
                        calories: (logItem.calories / servings) * ratio,
                        protein: (logItem.protein / servings) * ratio,
                        carbs: (logItem.carbs / servings) * ratio,
                        fat: (logItem.fat / servings) * ratio,
                        sugar: ((logItem.sugar || 0) / servings) * ratio,
                        sodium: ((logItem.sodium || 0) / servings) * ratio,
                        potassium: ((logItem.potassium || 0) / servings) * ratio,
                    });
                }
                saveData();
                fullRender();
            }

            function showUndo(type, data) {
                clearTimeout(undoTimeout);
                lastAction = { type, data };
                let text;
                if (type === 'delete') {
                    text = `Deleted "${data.item.name}"`;
                } else if (type === 'edit') {
                    text = `Edited "${data.originalItem.name}"`;
                } else if (type === 'water') {
                    text = `Water updated to ${data.newWater}ml`;
                }

                ui.undoToastText.textContent = text;
                ui.undoToast.classList.add('show'); // Use 'show' class

                undoTimeout = setTimeout(() => {
                    hideUndo();
                }, 5000);
            }

            function hideUndo() {
                lastAction = null;
                ui.undoToast.classList.remove('show');
            }

            function setupCarousel(containerId, prevBtnId, nextBtnId) {
                const container = document.getElementById(containerId);
                const prevBtn = document.getElementById(prevBtnId);
                const nextBtn = document.getElementById(nextBtnId);
                const wrapper = container ? container.closest('.carousel-wrapper') : null;

                if (!container || !prevBtn || !nextBtn || !wrapper) {
                     console.warn(`Carousel setup failed for ${containerId}. Missing elements.`);
                     return;
                }

                const updateCarouselButtons = () => {
                    // Recalculate dimensions inside the handler
                    const scrollLeft = container.scrollLeft;
                    const scrollWidth = container.scrollWidth;
                    const clientWidth = container.clientWidth;

                    prevBtn.classList.toggle('visible', scrollLeft > 10);
                    nextBtn.classList.toggle('visible', scrollLeft < scrollWidth - clientWidth - 10);
                };

                const scrollAmount = () => {
                    const firstItem = container.querySelector('.scroll-item');
                    return firstItem ? firstItem.offsetWidth + 16 : container.offsetWidth * 0.9;
                };

                prevBtn.onclick = () => {
                    container.scrollBy({ left: -scrollAmount(), behavior: 'smooth' });
                };

                nextBtn.onclick = () => {
                    container.scrollBy({ left: scrollAmount(), behavior: 'smooth' });
                };

                container.addEventListener('scroll', updateCarouselButtons);
                setTimeout(updateCarouselButtons, 100);
            }

            // --- NEW: Compound Food Modal Functions ---

            function addIngredientRow() {
                const newRowFragment = ui.ingredientTemplate.content.cloneNode(true);
                const newRow = newRowFragment.firstElementChild;
                const ingredientNumber = ui.ingredientListContainer.querySelectorAll('.ingredient-row').length + 1;
                newRow.querySelector('.ingredient-number').textContent = ingredientNumber;
                const uniqueIdSuffix = `_row_${ingredientNumber}`;
                const inputs = newRow.querySelectorAll('input[type="text"], input[type="number"]');
                inputs.forEach(input => {
                    const label = input.closest('div').querySelector('label');
                    if (label) {
                        const idName = Array.from(input.classList).find(c => c.startsWith('ingredient-'));
                        if (idName) {
                            const newId = `${idName}${uniqueIdSuffix}`;
                            input.id = newId;
                            label.setAttribute('for', newId);
                        }
                    }
                });
                ui.ingredientListContainer.appendChild(newRow);
                lucide.createIcons({ nodes: [newRow] });
                updateIngredientNumbers();
                newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                validateLastRow();
                setupCarousel('ingredient-list-container', 'recipe-prev-ingredient', 'recipe-next-ingredient');
            }

            function validateLastRow() {
                const hasRecipeName = ui.recipeNameInput.value.trim() !== '';
                if (!hasRecipeName) {
                    ui.addIngredientBtn.disabled = true;
                    return false;
                }
                const allRows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                if (allRows.length === 0) {
                    ui.addIngredientBtn.disabled = false;
                    ui.addIngredientBtn.removeAttribute('title');
                    return true;
                }
                const lastRow = allRows[allRows.length - 1];
                const name = lastRow.querySelector('.ingredient-name').value.trim();
                const isValid = name !== '';
                ui.addIngredientBtn.disabled = !isValid;
                if (isValid) {
                    ui.addIngredientBtn.removeAttribute('title');
                } else {
                    ui.addIngredientBtn.setAttribute('title', 'Please fill out the ingredient name first.');
                }
                return isValid;
            }

            function updateIngredientNumbers() {
                const rows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                rows.forEach((row, index) => {
                    const numberSpan = row.querySelector('.ingredient-number');
                    if (numberSpan) {
                        numberSpan.textContent = index + 1;
                    }
                });
            }

            function updateRecipeTotals() {
                const rows = ui.ingredientListContainer.querySelectorAll('.ingredient-row');
                let total = { calories: 0, protein: 0, carbs: 0, fat: 0, grams: 0, sugar: 0, sodium: 0, potassium: 0 };
                rows.forEach(row => {
                    const getVal = (selector) => parseFloat(row.querySelector(selector).value) || 0;
                    const quantity = getVal('.ingredient-quantity') || 1;
                    total.grams += getVal('.ingredient-grams') * quantity;
                    total.calories += getVal('.ingredient-calories') * quantity;
                    total.protein += getVal('.ingredient-protein') * quantity;
                    total.carbs += getVal('.ingredient-carbs') * quantity;
                    total.fat += getVal('.ingredient-fat') * quantity;
                    total.sugar += getVal('.ingredient-sugar') * quantity;
                    total.sodium += getVal('.ingredient-sodium') * quantity;
                    total.potassium += getVal('.ingredient-potassium') * quantity;
                });
                const setTotal = (id, value, maxDecimals = 1) => {
                    const el = document.getElementById(id);
                    if (el) {
                         el.textContent = parseFloat(value.toFixed(maxDecimals));
                    }
                };
                const setTotalSpan = (id, value, maxDecimals = 1) => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.textContent = parseFloat(value.toFixed(maxDecimals));
                    }
                };
                setTotal('recipe-total-calories', total.calories, 0);
                setTotalSpan('recipe-total-protein', total.protein);
                setTotalSpan('recipe-total-carbs', total.carbs);
                setTotalSpan('recipe-total-fat', total.fat);
                setTotal('recipe-total-grams', total.grams, 0);
                setTotalSpan('recipe-total-sugar', total.sugar);
                setTotalSpan('recipe-total-sodium', total.sodium, 0);
                setTotalSpan('recipe-total-potassium', total.potassium, 0);
            }

             let ingredientAbortController = null;

            async function fetchIngredientMacros(recipeName, ingredientData, signal) {
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                let userQuery = `Recipe context: "${recipeName}". Ingredient: "${ingredientData.quantity || 1} ${ingredientData.name}".`;
                const providedInfo = [];
                if (ingredientData.grams && ingredientData.grams > 0) providedInfo.push(`Amount: ${ingredientData.grams}g`);
                if (ingredientData.calories && ingredientData.calories > 0) providedInfo.push(`Calories: ${ingredientData.calories}kcal`);
                if (ingredientData.protein && ingredientData.protein > 0) providedInfo.push(`Protein: ${ingredientData.protein}g`);
                if (ingredientData.carbs && ingredientData.carbs > 0) providedInfo.push(`Carbs: ${ingredientData.carbs}g`);
                if (ingredientData.fat && ingredientData.fat > 0) providedInfo.push(`Fat: ${ingredientData.fat}g`);
                if (providedInfo.length > 0) {
                    userQuery += ` Provided info: ${providedInfo.join(', ')}.`;
                }
                 if (ingredientData.grams && ingredientData.grams > 0) {
                      userQuery += ` Please find all nutritional data for the specified ${ingredientData.grams}g amount.`;
                 } else {
                      userQuery += ` Amount not specified, so please estimate a typical single serving size in grams and find all nutritional data for that estimated amount.`;
                 }
                const systemPrompt = "You are a nutritional database. Given a recipe context, an ingredient name, and (optionally) some existing nutritional data (like grams or protein), find all missing nutritional information and return the complete set. Respond only with the valid JSON object described in the schema. Do not include 'g' or 'mg' units, just the numbers. For sugar, sodium, and potassium, if data is unavailable, return 0.";
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: systemPrompt }]
                    },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "grams": { "type": "NUMBER", "description": "The weight in grams. Use the provided amount or estimate if not provided." },
                                "calories": { "type": "NUMBER", "description": "Total kilocalories." },
                                "protein": { "type": "NUMBER", "description": "Grams of protein." },
                                "carbs": { "type": "NUMBER", "description": "Grams of carbohydrates." },
                                "fat": { "type": "NUMBER", "description": "Grams of fat." },
                                "sugar": { "type": "NUMBER", "description": "Grams of sugar. Return 0 if unknown." },
                                "sodium": { "type": "NUMBER", "description": "Milligrams of sodium. Return 0 if unknown." },
                                "potassium": { "type": "NUMBER", "description": "Milligrams of potassium. Return 0 if unknown." }
                            },
                            required: ["grams", "calories", "protein", "carbs", "fat", "sugar", "sodium", "potassium"]
                        }
                    }
                };
                 try {
                     const result = await fetchWithBackoff(apiUrl, payload);
                     if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                     const jsonText = result.candidates[0].content.parts[0].text;
                     const parsedJson = JSON.parse(jsonText);
                     return parsedJson;
                 } catch (error) {
                      if (error.name === 'AbortError') {
                         console.log("Ingredient fetch aborted.");
                      } else {
                         console.error("Fetch Ingredient Error:", error);
                      }
                      throw error;
                 }
            }

            function handleSaveRecipeAndLog() {
                const recipeName = capitalizeWords(ui.recipeNameInput.value.trim());
                const totalGrams = parseFloat(document.getElementById('recipe-total-grams').textContent) || 0;
                if (!recipeName) {
                    showCustomAlert('Missing Name', 'Please enter a name for your recipe.');
                    return;
                }
                 if (ui.ingredientListContainer.querySelectorAll('.ingredient-row').length === 0 || totalGrams <= 0 || parseFloat(document.getElementById('recipe-total-calories').textContent) <= 0) {
                     showCustomAlert('Missing Ingredients', 'Please add at least one ingredient with calories to save the recipe.');
                     return;
                 }
                const isDuplicate = favoriteFoods.some(f => f.name.toLowerCase() === recipeName.toLowerCase()) || savedRecipes.some(r => r.name.toLowerCase() === recipeName.toLowerCase());
                if (isDuplicate) {
                    showCustomAlert('Duplicate Name', 'An item with this name already exists in your favorites or recipes. Please choose a unique name.');
                    return;
                }
                const totalCalories = parseFloat(document.getElementById('recipe-total-calories').textContent) || 0;
                const totalProtein = parseFloat(document.getElementById('recipe-total-protein').textContent) || 0;
                const totalCarbs = parseFloat(document.getElementById('recipe-total-carbs').textContent) || 0;
                const totalFat = parseFloat(document.getElementById('recipe-total-fat').textContent) || 0;
                const totalSugar = parseFloat(document.getElementById('recipe-total-sugar').textContent) || 0;
                const totalSodium = parseFloat(document.getElementById('recipe-total-sodium').textContent) || 0;
                const totalPotassium = parseFloat(document.getElementById('recipe-total-potassium').textContent) || 0;
                const recipeBatch = {
                    name: recipeName, type: 'recipe', servings: 1, grams: totalGrams,
                    calories: totalCalories, protein: totalProtein, carbs: totalCarbs, fat: totalFat,
                    sugar: totalSugar, sodium: totalSodium, potassium: totalPotassium
                };
                savedRecipes.unshift(recipeBatch);
                const dayLog = getDayLog(viewDate);
                dayLog.entries.unshift({ ...recipeBatch, servings: 1, logId: Date.now() });
                saveData();
                hideModal(ui.compoundFoodModal);
                updateDayView(viewDate);
                ui.recipeNameInput.value = '';
                ui.ingredientListContainer.innerHTML = '';
                addIngredientRow();
                ui.ingredientListContainer.classList.add('section-disabled');
                document.getElementById('recipe-totals-container').querySelectorAll('p:not(.text-xs)').forEach(p => p.textContent = '0');
                showCustomAlert('Recipe Saved & Logged', `${recipeName} saved and logged to today's entry.`);
            }
            // --- END NEW Compound Food Modal Functions ---

            // --- EVENT LISTENERS ---
            ui.addFoodBtn.addEventListener('click', async () => {
                ui.addFoodError.textContent = '';
                const btn = ui.addFoodBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');

                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                const servings = parseFloat(ui.foodServingsInput.value);

                if (!foodName || isNaN(servings) || servings <= 0) {
                    ui.addFoodError.textContent = "Please enter a valid food name and serving amount.";
                    return;
                }

                let singleServingMacros = {};
                let manualMacros = {};
                let manualMacroCount = 0;
                let hasError = false;
                const macroKeys = ['calories', 'protein', 'carbs', 'fat', 'sugar', 'sodium', 'potassium'];

                macroKeys.forEach(m => {
                    const input = document.getElementById(`food-${m}-input`);
                    const valStr = input.value.trim();
                    if (valStr !== '') {
                        const val = parseFloat(valStr);
                        if (!isNaN(val) && val < 0) {
                            ui.addFoodError.textContent = "Macro values cannot be negative.";
                            input.classList.add('!border-red-500');
                            hasError = true;
                        } else if (!isNaN(val)) {
                            input.classList.remove('!border-red-500');
                            singleServingMacros[m] = val;
                            manualMacros[m] = val;
                            manualMacroCount++;
                        }
                    } else {
                        singleServingMacros[m] = 0; // Default to 0 if empty
                    }
                });

                if (hasError) return;

                let servingGrams = parseFloat(ui.foodGramsInput.value) || 0;
                 const savedItem = favoriteFoods.find(f => f.name.toLowerCase() === foodName.toLowerCase()) || savedRecipes.find(r => r.name.toLowerCase() === foodName.toLowerCase());

                 if (!savedItem && manualMacroCount === 0) {
                     btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                     try {
                         const brand = ui.foodBrandInput.value.trim();
                         const data = await getMacrosFromAI(foodName, brand);
                         servingGrams = 100;
                         singleServingMacros = {
                             calories: parseFloat(data.calories) || 0,
                             protein: parseFloat(data.protein) || 0,
                             carbs: parseFloat(data.carbs) || 0,
                             fat: parseFloat(data.fat) || 0,
                             sugar: parseFloat(data.sugar) || 0,
                             sodium: parseFloat(data.sodium) || 0,
                             potassium: parseFloat(data.potassium) || 0
                         };
                          const userGrams = parseFloat(ui.foodGramsInput.value);
                         if (!isNaN(userGrams) && userGrams > 0) {
                             const ratio = userGrams / 100.0;
                             servingGrams = userGrams;
                             for (const key in singleServingMacros) { singleServingMacros[key] *= ratio; }
                         } else {
                              ui.foodGramsInput.value = servingGrams.toFixed(0);
                         }
                         document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                         document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                         document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                         document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                         document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                         document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                         document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                     } catch (error) {
                         console.error("AI Get Macros Error:", error);
                          ui.addFoodError.textContent = `Could not fetch nutrition data. ${error.message}`;
                     } finally {
                         btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                     }
                 } else if (savedItem && manualMacroCount === 0) {
                      servingGrams = savedItem.grams || (savedItem.type === 'food' ? 100 : 0);
                      singleServingMacros = {
                          calories: savedItem.calories || 0,
                          protein: savedItem.protein || 0,
                          carbs: savedItem.carbs || 0,
                          fat: savedItem.fat || 0,
                          sugar: savedItem.sugar || 0,
                          sodium: savedItem.sodium || 0,
                          potassium: savedItem.potassium || 0,
                      };
                      ui.foodGramsInput.value = servingGrams > 0 ? servingGrams.toFixed(0) : '';
                      document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                      document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                      document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                      document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                      document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                      document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                      document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                 } else if (manualMacroCount > 0 && manualMacroCount < macroKeys.length) {
                      btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden');
                          try {
                              const brand = ui.foodBrandInput.value.trim();
                              const data = await getPartialMacrosFromAI(foodName, brand, manualMacros);
                              servingGrams = data.servingGrams || servingGrams || 0;
                              singleServingMacros = {
                                  calories: manualMacros.calories ?? (parseFloat(data.calories) || 0),
                                  protein: manualMacros.protein ?? (parseFloat(data.protein) || 0),
                                  carbs: manualMacros.carbs ?? (parseFloat(data.carbs) || 0),
                                  fat: manualMacros.fat ?? (parseFloat(data.fat) || 0),
                                  sugar: manualMacros.sugar ?? (parseFloat(data.sugar) || 0),
                                  sodium: manualMacros.sodium ?? (parseFloat(data.sodium) || 0),
                                  potassium: manualMacros.potassium ?? (parseFloat(data.potassium) || 0),
                              };
                              document.getElementById('food-calories-input').value = singleServingMacros.calories.toFixed(0);
                              document.getElementById('food-protein-input').value = singleServingMacros.protein.toFixed(1);
                              document.getElementById('food-carbs-input').value = singleServingMacros.carbs.toFixed(1);
                              document.getElementById('food-fat-input').value = singleServingMacros.fat.toFixed(1);
                              document.getElementById('food-sugar-input').value = singleServingMacros.sugar.toFixed(1);
                              document.getElementById('food-sodium-input').value = singleServingMacros.sodium.toFixed(0);
                              document.getElementById('food-potassium-input').value = singleServingMacros.potassium.toFixed(0);
                              if (servingGrams > 0) ui.foodGramsInput.value = servingGrams.toFixed(0);
                          } catch (error) {
                              console.error("AI Partial Macros Error:", error);
                              ui.addFoodError.textContent = `Could not estimate missing macros. ${error.message}`;
                          } finally {
                              btn.disabled = false; btnText.style.display = 'inline-block'; loader.classList.add('hidden');
                          }
                 }
                if (ui.addFoodError.textContent) return;

                const dayLog = getDayLog(viewDate);
                const totalMacros = {};
                macroKeys.forEach(m => {
                    totalMacros[m] = (singleServingMacros[m] || 0) * servings;
                });
                 const foodItem = {
                      name: foodName, brand: ui.foodBrandInput.value.trim(), servings,
                      grams: servingGrams * servings, ...totalMacros, logId: Date.now()
                 };
                if (editingFoodLogIndex !== null) {
                    const originalItem = { ...dayLog.entries[editingFoodLogIndex] };
                    dayLog.entries[editingFoodLogIndex] = foodItem;
                    showUndo('edit', { index: editingFoodLogIndex, originalItem: originalItem });
                    editingFoodLogIndex = null;
                } else {
                    dayLog.entries.unshift(foodItem);
                }
                ui.logMealForm.reset();
                ui.foodServingsInput.value = 1;
                saveData();
                updateDayView(viewDate);
            });

            const updateWater = (amount, isSetTotal = false) => {
                const dayLog = getDayLog(viewDate);
                const originalWater = dayLog.water || 0;
                let newWater;
                if (isSetTotal) {
                    newWater = Math.max(0, amount);
                } else {
                    newWater = Math.max(0, originalWater + amount);
                    lastWaterLogAmount = amount;
                }
                if (newWater !== originalWater) {
                    dayLog.water = newWater;
                    saveData();
                    updateDayView(viewDate);
                    if (!isSetTotal && lastWaterLogAmount !== 0) {
                         showUndo('water', { originalWater: originalWater, newWater: newWater });
                    }
                } else {
                    if (!isSetTotal) {
                         lastWaterLogAmount = 0;
                    }
                }
            };

            let waterPointerStart = { x: 0, y: 0 };
            let waterPointerDelta = { x: 0, y: 0 };
            let isWaterSwiping = false;
            let waterCurrentX = 0;

            function onWaterPointerDown(e) {
                const coords = getPointerCoordinates(e);
                waterPointerStart.x = coords.x;
                waterPointerStart.y = coords.y;
                waterPointerDelta = { x: 0, y: 0 };
                isWaterSwiping = false;
                waterCurrentX = 0;
                ui.waterSwipeContent.classList.add('swiping');
                ui.waterSwipeContent.style.transform = '';
                document.addEventListener('mousemove', onWaterPointerMove);
                document.addEventListener('mouseup', onWaterPointerUp);
                document.addEventListener('touchmove', onWaterPointerMove, { passive: false });
                document.addEventListener('touchend', onWaterPointerUp);
            }

            function onWaterPointerMove(e) {
                const coords = getPointerCoordinates(e);
                waterPointerDelta.x = coords.x - waterPointerStart.x;
                waterPointerDelta.y = coords.y - waterPointerStart.y;
                if (!isWaterSwiping && (Math.abs(waterPointerDelta.x) > 10 || Math.abs(waterPointerDelta.y) > 10)) {
                    isWaterSwiping = true;
                }
                if (isWaterSwiping) {
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x) && Math.abs(waterPointerDelta.y) > 10) {
                        if (e.cancelable) e.preventDefault();
                    }
                    const waterSwipeBgTop = document.getElementById('water-swipe-bg-top');
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                        // VERTICAL SWIPE
                        waterCurrentX = 0;
                        ui.waterSwipeContent.style.transform = 'translateX(0px)';
                        
                        // USER EDIT: Removed lines that hide horizontal icons
                        // ui.waterSwipeBgLeft.style.opacity = '0';
                        // ui.waterSwipeBgRight.style.opacity = '0'; 

                        if (waterPointerDelta.y > 0) { // Swiping Down
                            waterSwipeBgTop.style.opacity = Math.min(1, waterPointerDelta.y / 80).toString();
                            waterSwipeBgTop.style.height = `${waterPointerDelta.y}px`;
                            ui.waterSwipeContent.style.transform = `translateY(${waterPointerDelta.y}px)`;
                        } else { // Swiping Up
                            waterSwipeBgTop.style.opacity = '0';
                            waterSwipeBgTop.style.height = '0';
                            ui.waterSwipeContent.style.transform = `translateY(0px)`;
                        }
                    } else {
                        // HORIZONTAL SWIPE
                        
                        // USER EDIT: Removed lines that hide vertical icon
                        // waterSwipeBgTop.style.opacity = '0';
                        // waterSwipeBgTop.style.height = '0';

                        ui.waterSwipeContent.style.transform = `translateY(0px)`;
                        waterCurrentX = waterPointerDelta.x;
                        ui.waterSwipeContent.style.transform = `translateX(${waterCurrentX}px)`;
                        if (waterCurrentX < 0) { // Swiping Left
                            ui.waterSwipeBgLeft.style.opacity = Math.min(1, Math.abs(waterCurrentX) / 80).toString();
                            ui.waterSwipeBgRight.style.opacity = '0';
                        } else { // Swiping Right
                            ui.waterSwipeBgRight.style.opacity = Math.min(1, waterCurrentX / 80).toString();
                            ui.waterSwipeBgLeft.style.opacity = '0';
                        }
                    }
                }
            }

            function onWaterPointerUp(e) {
                document.removeEventListener('mousemove', onWaterPointerMove);
                document.removeEventListener('mouseup', onWaterPointerUp);
                document.removeEventListener('touchmove', onWaterPointerMove);
                document.removeEventListener('touchend', onWaterPointerUp);
                ui.waterSwipeContent.classList.add('returning');
                ui.waterSwipeContent.classList.remove('swiping');
                const waterSwipeBgTop = document.getElementById('water-swipe-bg-top');
                ui.waterSwipeBgLeft.style.opacity = '0';
                ui.waterSwipeBgRight.style.opacity = '0';
                waterSwipeBgTop.style.opacity = '0';
                waterSwipeBgTop.style.height = '0';
                const totalDistance = Math.sqrt(waterPointerDelta.x**2 + waterPointerDelta.y**2);
                const swipeThreshold = 30;
                const horizontalSwipeThreshold = ui.waterSwipeContent.offsetWidth * 0.35;
                if (!isWaterSwiping && totalDistance < 10) {
                    const defaultSize = userProfile.waterServingSize || 250;
                    updateWater(defaultSize);
                    ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                } else if (isWaterSwiping) {
                    if (Math.abs(waterPointerDelta.y) > Math.abs(waterPointerDelta.x)) {
                        ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                        if (waterPointerDelta.y < -swipeThreshold) {
                            // Swipe Up: Does nothing
                        } else if (waterPointerDelta.y > swipeThreshold) {
                            // CHANGE 3: Updated prompt callback with new min/max logic
                            const MIN_WATER_GOAL = 1500;
                            const MAX_WATER_GOAL = 4500;
                            showPromptModal("Set Water Goal", "Enter your new daily water goal (ml):", goals.water, (newGoalStr) => {
                                if (newGoalStr === null) return;
                                const newGoal = parseInt(newGoalStr);
                                if (!isNaN(newGoal) && newGoal >= MIN_WATER_GOAL && newGoal <= MAX_WATER_GOAL) {
                                    goals.water = newGoal;
                                    saveData();
                                    updateDayView(viewDate);
                                } else {
                                    showCustomAlert("Invalid Goal", `Please enter a number between ${MIN_WATER_GOAL}ml and ${MAX_WATER_GOAL}ml.`);
                                }
                            });
                        }
                    } else {
                        if (waterCurrentX < -horizontalSwipeThreshold) {
                            showPromptModal("Set Glass Size", "Enter your default water glass size (ml):", userProfile.waterServingSize || 250, (newSizeStr) => {
                                if (newSizeStr === null) return;
                                const newSize = parseInt(newSizeStr);
                                if (!isNaN(newSize) && newSize > 0) {
                                    userProfile.waterServingSize = newSize;
                                    saveData();
                                    showCustomAlert("Glass Size Updated", `Your default glass size is now ${newSize}ml.`);
                                } else {
                                    showCustomAlert("Invalid Size", "Please enter a positive number for your glass size.");
                                }
                            });
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                        } else if (waterCurrentX > horizontalSwipeThreshold) {
                            const defaultSize = userProfile.waterServingSize || 250;
                            updateWater(-defaultSize);
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                        } else {
                            ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                        }
                    }
                } else {
                    ui.waterSwipeContent.style.transform = 'translateX(0) translateY(0)';
                }
                setTimeout(() => {
                    if (ui.waterSwipeContent) {
                        ui.waterSwipeContent.classList.remove('returning');
                        ui.waterSwipeContent.style.transform = '';
                    }
                }, 300);
                isWaterSwiping = false;
                waterPointerDelta = { x: 0, y: 0 };
                waterCurrentX = 0;
            }

            ui.addWaterBtn.addEventListener('mousedown', onWaterPointerDown);
            ui.addWaterBtn.addEventListener('touchstart', onWaterPointerDown, { passive: true });
            
            ui.aiMacroSwapBtn.addEventListener('click', async () => {
                const btn = ui.aiMacroSwapBtn;
                const btnText = btn.querySelector('.btn-text');
                const loader = btn.querySelector('.loader');
                const foodName = capitalizeWords(ui.foodNameInput.value.trim());
                if (!foodName) {
                    showCustomAlert("No Food Entered", "Please enter a food name in the form first.");
                    return;
                }
                btn.disabled = true;
                btnText.style.display = 'none';
                loader.classList.remove('hidden');
                ui.aiSwapFoodName.textContent = foodName;
                showModal(ui.aiMacroSwapModal);
                ui.aiMacroSwapOutput.innerHTML = '<div class="loader mx-auto"></div>';
                try {
                    const swaps = await getAiMacroSwaps(foodName);
                    if (swaps && swaps.length > 0) {
                        ui.aiMacroSwapOutput.innerHTML = swaps.map(swap => `
                            <button type="button" class="btn btn-secondary w-full !justify-between !text-left swap-suggestion-btn" data-food-name="${swap.name}">
                                <div class="flex flex-col">
                                    <span class="font-semibold text-white">${swap.name}</span>
                                    <span class="text-xs text-gray-400 font-normal">${swap.reason}</span>
                                </div>
                                <i data-lucide="chevron-right" class="w-5 h-5 text-gray-400"></i>
                            </button>
                        `).join('');
                        lucide.createIcons();
                    } else {
                        ui.aiMacroSwapOutput.innerHTML = `<p class="text-gray-400 text-center">No swap suggestions found for "${foodName}".</p>`;
                    }
                } catch (error) {
                    console.error("AI Macro Swap Error:", error);
                    ui.aiMacroSwapOutput.innerHTML = `<p class="text-red-400">${error.message}</p>`;
                } finally {
                    btn.disabled = false;
                    btnText.style.display = 'inline-block';
                    loader.classList.add('hidden');
                }
            });

            async function getAiMacroSwaps(foodName) {
                userProfile = JSON.parse(localStorage.getItem('fitTrackAI_userProfile')) || { goal: 'maintain weight' };
                const systemPrompt = `User is considering eating '${foodName}'. Their goal is ${userProfile.goal}. Suggest 3-5 healthier alternatives that fit a similar craving (e.g., salty, sweet, crunchy). For each, provide 'name' and 'reason' (why it's better, e.g., "Lower in fat", "Higher in protein"). Respond ONLY with a valid JSON array of objects: [{name: "Food 1", reason: "Lower in fat"}, {name: "Food 2", reason: "Higher in protein"}]`;
                const userQuery = `Suggest swaps for ${foodName}`;
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: { responseMimeType: "application/json" }
                };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    return JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("getAiMacroSwaps Error:", error);
                    throw error;
                }
            }

            ui.closeAiMacroSwapModalBtn.addEventListener('click', () => hideModal(ui.aiMacroSwapModal));

            ui.aiMacroSwapOutput.addEventListener('click', (e) => {
                const swapBtn = e.target.closest('.swap-suggestion-btn');
                if (swapBtn) {
                    const foodName = swapBtn.dataset.foodName;
                    if (foodName) {
                        ui.foodNameInput.value = foodName;
                        const macroInputs = ui.logMealForm.querySelectorAll('.macro-input');
                        macroInputs.forEach(input => input.value = '');
                        ui.foodGramsInput.value = '';
                        ui.foodBrandInput.value = '';
                        ui.foodServingsInput.value = 1;
                        hideModal(ui.aiMacroSwapModal);
                        ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
                        ui.addFoodBtn.click();
                    }
                }
            });

            const handleEditLogItem = (index) => {
                 const item = getCurrentDayLogEntries()[index];
                 if(!item) return;
                editingFoodLogIndex = index;
                ui.foodNameInput.value = item.name;
                ui.foodServingsInput.value = item.servings;
                const singleServingGrams = (item.grams / item.servings) || 0;
                ui.foodGramsInput.value = singleServingGrams > 0 ? singleServingGrams.toFixed(1) : '';
                document.getElementById('food-calories-input').value = ((item.calories / item.servings) || 0).toFixed(2);
                document.getElementById('food-protein-input').value = ((item.protein / item.servings) || 0).toFixed(2);
                document.getElementById('food-carbs-input').value = ((item.carbs / item.servings) || 0).toFixed(2);
                document.getElementById('food-fat-input').value = ((item.fat / item.servings) || 0).toFixed(2);
                document.getElementById('food-sugar-input').value = ((item.sugar / item.servings) || 0).toFixed(2);
                document.getElementById('food-sodium-input').value = ((item.sodium / item.servings) || 0).toFixed(2);
                document.getElementById('food-potassium-input').value = ((item.potassium / item.servings) || 0).toFixed(2);
                const detailsElement = ui.logMealForm.querySelector('details');
                if (detailsElement) detailsElement.open = true;
                ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
             };

            const handleDeleteLogItem = (index) => {
                showConfirmModal('Delete Log Entry?', 'Are you sure?', () => {
                    let dayLog = getDayLog(viewDate);
                    if (dayLog && dayLog.entries && dayLog.entries[index]) {
                        const itemToDelete = dayLog.entries.splice(index, 1)[0];
                        saveData();
                        fullRender();
                        showUndo('delete', { index, item: itemToDelete });
                        if (editingFoodLogIndex === index) {
                            ui.logMealForm.reset();
                            ui.foodServingsInput.value = 1;
                            const detailsElement = ui.logMealForm.querySelector('details');
                            if (detailsElement) detailsElement.open = false;
                            editingFoodLogIndex = null;
                        }
                    }
                });
            };

            ui.aiDailyReportBtn.addEventListener('click', getDailyLogAIReport);
            ui.closeAiReportModalBtn.addEventListener('click', () => hideModal(ui.aiReportModal));
            ui.aiReportModalOkBtn.addEventListener('click', () => hideModal(ui.aiReportModal));

            ['food-name-input', 'food-brand-input'].forEach(id => document.getElementById(id).addEventListener('input', () => { aiBaseMacros = null; }));
            
            ui.closeAiSuggesterModalBtn.addEventListener('click', () => hideModal(ui.aiSuggesterModal));
            ui.aiSuggestionBtn.addEventListener('click', async () => {
                const btn = ui.aiSuggestionBtn, btnText = btn.querySelector('.btn-text'), loader = btn.querySelector('.loader');
                const ingredients = ui.aiIngredientsInput.value.trim();
                if (!ingredients) { ui.aiSuggestionsOutput.innerHTML = `<p class="text-yellow-400">Please enter some ingredients.</p>`; return; }
                btn.disabled = true; btnText.style.display = 'none'; loader.classList.remove('hidden'); ui.aiSuggestionsOutput.innerHTML = '';
                const currentDayLogEntries = getCurrentDayLogEntries();
                const remainingCalories = Math.max(0, goals.calories - currentDayLogEntries.reduce((sum, item) => sum + item.calories, 0));
                const prompt = `I have: ${ingredients}. I have about ${remainingCalories} calories left. My goal is ${userProfile.goal}. Suggest one simple, healthy meal. Provide the name, prep/cook time, and simple step-by-step instructions. Format with Markdown.`;
                const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                try {
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    let text = result.candidates[0].content.parts[0].text;
                    text = text.replace(/\*\*(.*?)\*\*/g, '<h3 class="text-lg font-semibold mt-4 mb-2">$1</h3>').replace(/\*/g, '').replace(/(\d+\.)/g, '<br>$1');
                    ui.aiSuggestionsOutput.innerHTML = `<div class="bg-black/30 p-4 rounded-lg text-sm">${text}</div>`;
                } catch (error) {
                    console.error("AI Suggestion Error:", error);
                    ui.aiSuggestionsOutput.innerHTML = `<p class="text-red-400">Could not get a suggestion. ${error.message}</p>`;
                } finally {
                    btn.disabled = false; btnText.style.display = 'inline'; loader.classList.add('hidden');
                }
            });

            ui.closeAiNutritionistModalBtn.addEventListener('click', () => hideModal(ui.aiNutritionistModal));
            ui.aiChatSendBtn.addEventListener('click', handleAiChatSend);
            ui.aiChatInput.addEventListener('keydown', (e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleAiChatSend(); } });

            async function handleAiChatSend() {
                const userInput = ui.aiChatInput.value.trim();
                if(!userInput) return;
                chatHistory.push({ role: "user", parts: [{ text: userInput }] });
                addMessageToChat(userInput, 'user');
                ui.aiChatInput.value = '';
                ui.aiChatSendBtn.disabled = true;
                addMessageToChat('<div class="loader"></div>', 'model', true);
                try {
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    const recentLogs = Object.entries(allDailyLogs).filter(([date]) => new Date(date) >= sevenDaysAgo);
                    const context = `
                        User Profile: ${JSON.stringify(userProfile)}
                        Nutrition Goals: ${JSON.stringify(goals)}
                        Last 7 Days Food Log: ${JSON.stringify(recentLogs)}
                    `;
                    const systemPrompt = `You are FitTrack AI, a helpful and knowledgeable nutritionist. Analyze the user's provided data to give specific, actionable advice based on their question. Be encouraging and provide clear, concise answers. Here is the user's data context: ${context}`;
                    const apiUrl = getApiUrl('gemini-2.5-flash-preview-09-2025');
                    const payload = {
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    };
                    const result = await fetchWithBackoff(apiUrl, payload);
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error("Invalid API response format.");
                    const aiResponse = result.candidates[0].content.parts[0].text;
                    chatHistory.push({ role: "model", parts: [{ text: aiResponse }] });
                    updateLastMessage(aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'));
                } catch(error) {
                    console.error("AI Chat Error:", error);
                    updateLastMessage(`Sorry, I am having trouble connecting right now. ${error.message}`);
                    chatHistory.pop();
                } finally {
                    ui.aiChatSendBtn.disabled = false;
                    saveData();
                }
            }


            function renderChatHistory() {
                if(chatHistory.length === 0) {
                     ui.aiChatHistory.innerHTML = `<div class="text-center text-secondary-text p-4"><i data-lucide="bot" class="w-10 h-10 mx-auto mb-2"></i><p>Hello! I'm your AI Nutritionist. Ask me anything about your diet, food logs, or general nutrition.</p></div>`;
                     lucide.createIcons();
                } else {
                    ui.aiChatHistory.innerHTML = '';
                    chatHistory.forEach(msg => {
                        addMessageToChat(msg.parts[0].text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'), msg.role);
                    });
                }
            }


            function addMessageToChat(message, sender, isLoading = false) {
                 if (chatHistory.length === 1 && sender === 'user') { ui.aiChatHistory.innerHTML = ''; }
                const messageDiv = document.createElement('div');
                messageDiv.className = `p-3 rounded-lg max-w-[85%] ${sender === 'user' ? 'bg-blue-600 self-end' : 'bg-input-bg self-start'}`;
                if(isLoading) messageDiv.id = 'ai-loading-message';
                messageDiv.innerHTML = message;
                ui.aiChatHistory.appendChild(messageDiv);
                ui.aiChatHistory.scrollTop = ui.aiChatHistory.scrollHeight;
            }
             function updateLastMessage(newMessage) {
                const loadingMessage = document.getElementById('ai-loading-message');
                if (loadingMessage) {
                    loadingMessage.innerHTML = newMessage;
                    loadingMessage.removeAttribute('id');
                }
            }

            function handleItemDelete(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);
                const name = element.dataset.name;
                if (type === 'log') {
                    handleDeleteLogItem(index);
                } else if (type === 'food' || type === 'recipe') {
                    showConfirmModal(`Delete ${type}?`, `Are you sure you want to delete "${name}"?`, () => {
                        if (type === 'food') {
                            favoriteFoods.splice(index, 1);
                        } else if (type === 'recipe') {
                             savedRecipes.splice(index, 1);
                        }
                        saveData();
                        fullRender();
                    });
                }
            }

            function handleItemEdit(element) {
                const type = element.dataset.type;
                const index = parseInt(element.dataset.index);
                if (type === 'log') {
                    handleEditLogItem(index);
                } else if (type === 'food') {
                    const food = favoriteFoods[index];
                    if (!food) return;
                    editingFavoriteFoodName = food.name;
                    document.getElementById('edit-fav-food-name').value = food.name;
                    document.getElementById('edit-fav-food-calories').value = (food.calories || 0).toFixed(2);
                    document.getElementById('edit-fav-food-protein').value = (food.protein || 0).toFixed(2);
                    document.getElementById('edit-fav-food-carbs').value = (food.carbs || 0).toFixed(2);
                    document.getElementById('edit-fav-food-fat').value = (food.fat || 0).toFixed(2);
                    document.getElementById('edit-fav-food-sugar').value = (food.sugar || 0).toFixed(2);
                    document.getElementById('edit-fav-food-sodium').value = (food.sodium || 0).toFixed(0);
                    document.getElementById('edit-fav-food-potassium').value = (food.potassium || 0).toFixed(0);
                    showModal(ui.editFavoriteModal);
                } else if (type === 'recipe') {
                     showCustomAlert("Coming Soon", "Recipe editing is currently under development.");
                }
            }

            let pointerStart = { x: 0, y: 0 };
            let currentX = 0;
            let isSwiping = false;
            let swipedElement = null;
            let lastTap = 0;
            let pointerDelta = { x: 0, y: 0 };

            function getPointerCoordinates(e) {
                return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
            }

            function handlePointerDown(e) {
                const target = e.target.closest('.swipe-item');
                if (!target || e.target.closest('button, a, input, select, textarea')) return;
                const coords = getPointerCoordinates(e);
                pointerStart.x = coords.x;
                pointerStart.y = coords.y;
                pointerDelta = { x: 0, y: 0 };
                currentX = 0;
                swipedElement = target;
                swipedElement.querySelector('.swipe-content').classList.add('swiping');
                document.addEventListener('mousemove', handlePointerMove);
                document.addEventListener('mouseup', handlePointerUp);
                document.addEventListener('touchmove', handlePointerMove, { passive: false });
                document.addEventListener('touchend', handlePointerUp);
            }

            function handlePointerMove(e) {
                if (!swipedElement) return;
                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - pointerStart.x;
                const deltaY = coords.y - pointerStart.y;
                pointerDelta = { x: deltaX, y: deltaY };
                if (!isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isSwiping = true;
                }
                if (isSwiping) {
                    if (e.cancelable) e.preventDefault();
                    currentX = deltaX;
                    const content = swipedElement.querySelector('.swipe-content');
                    content.style.transform = `translateX(${currentX}px)`;
                    const rightAction = swipedElement.querySelector('.swipe-action-container.right');
                    const leftAction = swipedElement.querySelector('.swipe-action-container.left');
                    if (currentX < 0) {
                        if(rightAction) rightAction.style.opacity = Math.min(1, Math.abs(currentX) / 80).toString();
                        if(leftAction) leftAction.style.opacity = '0';
                    } else {
                        if(leftAction) leftAction.style.opacity = Math.min(1, currentX / 80).toString();
                        if(rightAction) rightAction.style.opacity = '0';
                    }
                }
            }

            function handlePointerUp(e) {
                document.removeEventListener('mousemove', handlePointerMove);
                document.removeEventListener('mouseup', handlePointerUp);
                document.removeEventListener('touchmove', handlePointerMove);
                document.removeEventListener('touchend', handlePointerUp);
                if (!swipedElement) return;
                const elementToClean = swipedElement;
                const content = elementToClean.querySelector('.swipe-content');
                const currentTime = new Date().getTime();
                const isDoubleTap = (currentTime - lastTap) < 300 && !isSwiping;
                lastTap = currentTime;
                const totalDistance = Math.sqrt(pointerDelta.x**2 + pointerDelta.y**2);
                if (isSwiping) {
                    const swipeThreshold = elementToClean.offsetWidth * 0.35;
                    content.classList.add('returning');
                    if (currentX < -swipeThreshold) {
                        handleItemEdit(elementToClean);
                        content.style.transform = 'translateX(0)';
                    } else if (currentX > swipeThreshold) {
                        handleItemDelete(elementToClean);
                    } else {
                        content.style.transform = 'translateX(0)';
                    }
                } else if (totalDistance < 10) {
                    if (isDoubleTap) {
                        const itemName = elementToClean.dataset.name;
                        if (itemName) {
                            toggleFavorite(itemName);
                        }
                    } else if (elementToClean.closest('#saved-items-list')) {
                        handleLogSavedItem(elementToClean);
                    }
                }
                isSwiping = false;
                swipedElement = null;
                currentX = 0;
                pointerDelta = { x: 0, y: 0 };
                if (elementToClean && document.body.contains(elementToClean)) {
                    setTimeout(() => {
                        if (content && content.style.transform !== '') {
                            content.classList.remove('swiping', 'returning');
                            content.style.transform = '';
                        }
                        const actions = elementToClean.querySelectorAll('.swipe-action-container');
                        if (actions) actions.forEach(el => el.style.opacity = '0');
                    }, 300);
                }
            }


            function handleLogSavedItem(element) {
                const name = element.dataset.name;
                const type = element.dataset.type;
                if (!name || !type) return;
                let itemData;
                let singleServingGrams = 0;
                let singleServingMacros = {};
                if (type === 'food') {
                    itemData = favoriteFoods.find(f => f.name === name);
                    if (!itemData) return;
                    singleServingGrams = 100;
                    singleServingMacros = {
                        calories: itemData.calories || 0,
                        protein: itemData.protein || 0,
                        carbs: itemData.carbs || 0,
                        fat: itemData.fat || 0,
                        sugar: itemData.sugar || 0,
                        sodium: itemData.sodium || 0,
                        potassium: itemData.potassium || 0,
                    };
                } else if (type === 'recipe') {
                    itemData = savedRecipes.find(r => r.name === name);
                    if (!itemData) return;
                    singleServingGrams = itemData.grams || 0;
                     singleServingMacros = {
                         calories: itemData.calories || 0,
                         protein: itemData.protein || 0,
                         carbs: itemData.carbs || 0,
                         fat: itemData.fat || 0,
                         sugar: itemData.sugar || 0,
                         sodium: itemData.sodium || 0,
                         potassium: itemData.potassium || 0,
                     };
                }
                if (!itemData) return;
                showPromptModal(`Log ${name}`, "How many servings?", "1", (servingsStr) => {
                    if (servingsStr === null) return;
                    const servings = parseFloat(servingsStr);
                    if (isNaN(servings) || servings <= 0) {
                        showCustomAlert("Invalid Amount", "Please enter a valid number of servings.");
                        return;
                    }
                    const totalMacros = {};
                    for (const key in singleServingMacros) {
                        totalMacros[key] = singleServingMacros[key] * servings;
                    }
                     const foodItem = {
                         name: itemData.name, brand: itemData.brand || '', servings: servings,
                         grams: singleServingGrams * servings, ...totalMacros, logId: Date.now()
                     };
                    const dayLog = getDayLog(viewDate);
                    dayLog.entries.unshift(foodItem);
                    saveData();
                    updateDayView(viewDate);
                });
            }

            ui.dailyLogContentDiv.addEventListener('mousedown', handlePointerDown);
            ui.dailyLogContentDiv.addEventListener('touchstart', handlePointerDown, { passive: true });
            ui.savedItemsListDiv.addEventListener('mousedown', handlePointerDown);
            ui.savedItemsListDiv.addEventListener('touchstart', handlePointerDown, { passive: true });

            let daySwipeStart = { x: 0, y: 0 };
            let daySwipeCurrentX = 0;
            let isDaySwiping = false;
            let daySwipeElement = null;

            function handleDaySwipePointerDown(e) {
                 const target = e.target.closest('#daily-summary-card');
                 if (!target || e.target.closest('span') || e.target.closest('#daily-log-content, #saved-items-list, #log-meal-form')) return;
                const coords = getPointerCoordinates(e);
                daySwipeStart.x = coords.x;
                daySwipeStart.y = coords.y;
                daySwipeCurrentX = 0;
                daySwipeElement = target;
                document.addEventListener('mousemove', handleDaySwipePointerMove);
                document.addEventListener('mouseup', handleDaySwipePointerUp);
                document.addEventListener('touchmove', handleDaySwipePointerMove, { passive: false });
                document.addEventListener('touchend', handleDaySwipePointerUp);
            }

            function handleDaySwipePointerMove(e) {
                if (!daySwipeElement) return;
                const coords = getPointerCoordinates(e);
                const deltaX = coords.x - daySwipeStart.x;
                const deltaY = coords.y - daySwipeStart.y;
                if (!isDaySwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                    isDaySwiping = true;
                }
                if (isDaySwiping) {
                    if (e.cancelable) e.preventDefault();
                    daySwipeCurrentX = deltaX;
                    daySwipeElement.style.transition = 'none';
                    daySwipeElement.style.transform = `translateX(${daySwipeCurrentX}px)`;
                }
            }

            function handleDaySwipePointerUp(e) {
                document.removeEventListener('mousemove', handleDaySwipePointerMove);
                document.removeEventListener('mouseup', handleDaySwipePointerUp);
                document.removeEventListener('touchmove', handleDaySwipePointerMove);
                document.removeEventListener('touchend', handleDaySwipePointerUp);
                if (!daySwipeElement) return;
                if (isDaySwiping) {
                    const swipeThreshold = daySwipeElement.offsetWidth * 0.25;
                    daySwipeElement.style.transition = 'transform 0.3s ease';
                    daySwipeElement.style.transform = 'translateX(0)';
                    if (daySwipeCurrentX < -swipeThreshold) {
                        const today = new Date(); today.setHours(0, 0, 0, 0);
                        const nextDay = new Date(viewDate); nextDay.setDate(nextDay.getDate() + 1);
                        if (nextDay.getTime() <= today.getTime()) {
                            viewDate.setDate(viewDate.getDate() + 1);
                            updateDayView(viewDate);
                        }
                    } else if (daySwipeCurrentX > swipeThreshold) {
                        viewDate.setDate(viewDate.getDate() - 1);
                        updateDayView(viewDate);
                    }
                }
                isDaySwiping = false;
                setTimeout(() => {
                    if(daySwipeElement) {
                       daySwipeElement.style.transition = '';
                       daySwipeElement.style.transform = '';
                    }
                    daySwipeElement = null;
                }, 300);
            }

            ui.dailySummaryCard.addEventListener('mousedown', handleDaySwipePointerDown);
            ui.dailySummaryCard.addEventListener('touchstart', handleDaySwipePointerDown, { passive: true });

            const resetToToday = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                updateDayView(today);
            };
            ui.dayViewTitleSpan.addEventListener('click', resetToToday);
            ui.dayViewDateSpan.addEventListener('click', resetToToday);

            ui.undoToastBtn.addEventListener('click', () => {
                if(!lastAction) return;
                const dayLog = getDayLog(viewDate);
                if(lastAction.type === 'delete') {
                    dayLog.entries.splice(lastAction.data.index, 0, lastAction.data.item);
                } else if (lastAction.type === 'edit') {
                    dayLog.entries[lastAction.data.index] = lastAction.data.originalItem;
                } else if (lastAction.type === 'water') {
                    dayLog.water = lastAction.data.originalWater;
                     lastWaterLogAmount = 0;
                }
                saveData();
                fullRender();
                hideUndo();
            });

            lucide.createIcons({ nodes: [ui.compoundFoodModal.querySelector('.disabled-overlay')] });
            if (ui.closeCompoundFoodModalBtn && ui.compoundFoodModal) {
                ui.closeCompoundFoodModalBtn.addEventListener('click', () => {
                    hideModal(ui.compoundFoodModal);
                });
            }
            if (ui.recipeNameInput && ui.ingredientListContainer && ui.addIngredientBtn) {
                ui.recipeNameInput.addEventListener('input', () => {
                    const hasName = ui.recipeNameInput.value.trim() !== '';
                    if (hasName) {
                        ui.ingredientListContainer.classList.remove('section-disabled');
                        validateLastRow();
                    } else {
                        ui.ingredientListContainer.classList.add('section-disabled');
                        ui.addIngredientBtn.disabled = true;
                    }
                });
            }
            if (ui.addIngredientBtn) {
                ui.addIngredientBtn.addEventListener('click', () => {
                    addIngredientRow();
                });
            }
            if (ui.compoundFoodForm) {
                 ui.compoundFoodForm.addEventListener('submit', (e) => {
                     e.preventDefault();
                     handleSaveRecipeAndLog();
                 });
            }
            if (ui.ingredientListContainer) {
                ui.ingredientListContainer.addEventListener('click', async (e) => {
                    const removeBtn = e.target.closest('.remove-ingredient-btn');
                    const aiBtn = e.target.closest('.find-macros-ai-btn');
                    const scanBtn = e.target.closest('.recipe-scan-btn');
                    const row = e.target.closest('.ingredient-row');
                    if (removeBtn && row) {
                        if (ui.ingredientListContainer.querySelectorAll('.ingredient-row').length > 1) {
                            row.remove();
                            updateIngredientNumbers();
                        } else {
                            row.querySelectorAll('input').forEach(input => {
                                if (input.classList.contains('ingredient-quantity')) {
                                    input.value = '1';
                                } else {
                                    input.value = '';
                                }
                            });
                        }
                        updateRecipeTotals();
                        validateLastRow();
                         setupCarousel('ingredient-list-container', 'recipe-prev-ingredient', 'recipe-next-ingredient');
                    }
                    if (aiBtn && row) {
                        e.preventDefault();
                        if (aiBtn.disabled) return;
                        const loader = aiBtn.querySelector('.loader');
                        const icon = aiBtn.querySelector('.lucide-icon');
                        const recipeName = ui.recipeNameInput.value.trim();
                        const ingredientData = {
                            quantity: row.querySelector('.ingredient-quantity').value.trim(),
                            name: row.querySelector('.ingredient-name').value.trim(),
                            grams: row.querySelector('.ingredient-grams').value.trim(),
                            calories: row.querySelector('.ingredient-calories').value.trim(),
                            protein: row.querySelector('.ingredient-protein').value.trim(),
                            carbs: row.querySelector('.ingredient-carbs').value.trim(),
                            fat: row.querySelector('.ingredient-fat').value.trim(),
                            sugar: row.querySelector('.ingredient-sugar').value.trim(),
                            sodium: row.querySelector('.ingredient-sodium').value.trim(),
                            potassium: row.querySelector('.ingredient-potassium').value.trim()
                        };
                        if (!ingredientData.name) { return; }
                        if (ingredientAbortController) { ingredientAbortController.abort(); }
                        ingredientAbortController = new AbortController();
                        row.dataset.loading = 'true';
                        aiBtn.disabled = true;
                        loader.classList.remove('hidden');
                        icon.classList.add('hidden');
                        try {
                            const data = await fetchIngredientMacros(recipeName, ingredientData, ingredientAbortController.signal);
                            if (ingredientAbortController.signal.aborted) return;
                            row.querySelector('.ingredient-grams').value = data.grams.toFixed(0);
                            row.querySelector('.ingredient-calories').value = data.calories.toFixed(0);
                            row.querySelector('.ingredient-protein').value = data.protein.toFixed(1);
                            row.querySelector('.ingredient-carbs').value = data.carbs.toFixed(1);
                            row.querySelector('.ingredient-fat').value = data.fat.toFixed(1);
                            row.querySelector('.ingredient-sugar').value = data.sugar.toFixed(1);
                            row.querySelector('.ingredient-sodium').value = data.sodium.toFixed(0);
                            row.querySelector('.ingredient-potassium').value = data.potassium.toFixed(0);
                            updateRecipeTotals();
                        } catch (error) {
                            if (error.name !== 'AbortError') { 
                                console.error("AI Macro Search Failed:", error);
                                // Show API error to user
                                showCustomAlert("AI Error", `Could not fetch macros. ${error.message}`);
                            }
                        } finally {
                            if (!ingredientAbortController || !ingredientAbortController.signal.aborted) {
                                aiBtn.disabled = false;
                                loader.classList.add('hidden');
                                icon.classList.remove('hidden');
                                delete row.dataset.loading;
                            }
                            ingredientAbortController = null;
                        }
                    }
                     if (scanBtn && row) {
                          activeRecipeScanBtn = scanBtn;
                          window.location.href = 'assets/nutrition/scan-combined.html?context=recipe';
                     }
                });
                ui.ingredientListContainer.addEventListener('input', (e) => {
                    if (e.target.type === 'number' && parseFloat(e.target.value) < 0) {
                        e.target.value = '';
                    }
                    updateRecipeTotals();
                    validateLastRow();
                    const row = e.target.closest('.ingredient-row');
                    if (row && ingredientAbortController && row.dataset.loading) {
                        ingredientAbortController.abort();
                    }
                });
            }

            // --- INITIAL LOAD AND RENDER (FIX for persistence) ---
            loadData();
            updateDayView(viewDate);
            setupCarousel('ai-scanner-results-container', 'ai-scanner-prev', 'ai-scanner-next');

            function checkUrlParams() {
                const urlParams = new URLSearchParams(window.location.search);
                const swapFood = urlParams.get('swapFood');
                const tempScannedItem = localStorage.getItem('fitTrackAI_tempScannedItem');

                if (swapFood) {
                    ui.foodNameInput.value = swapFood;
                    const macroInputs = ui.logMealForm.querySelectorAll('.macro-input');
                    macroInputs.forEach(input => input.value = '');
                    ui.foodGramsInput.value = '';
                    ui.foodBrandInput.value = '';
                    ui.foodServingsInput.value = 1;
                    ui.logMealForm.scrollIntoView({ behavior: 'smooth' });
                    showCustomAlert("Swap Applied", `Loaded "${swapFood}". Click the AI button to find macros.`);
                    history.replaceState(null, '', window.location.pathname);
                }
                
                if (tempScannedItem) {
                    try {
                        const item = JSON.parse(tempScannedItem);
                        const dayLog = getDayLog(viewDate);
                        dayLog.entries.unshift(item);
                        saveData();
                        fullRender();
                        showCustomAlert("Item Logged", `Successfully logged "${item.name}" from scanner.`);
                    } catch (e) {
                        console.error("Error parsing scanned item:", e);
                    }
                    localStorage.removeItem('fitTrackAI_tempScannedItem');
                }
            }
            checkUrlParams();
        }
        // --- END Original script ---

        // Initialize layout and page logic on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeLayout);
    </script>
</body>
</html>
